#!/usr/bin/env bash
# This script was generated by bashly 1.0.8 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

version_command() {
  echo "$version"
}

chronom_cli_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli - Chronom A.I. Command Line Interface\n"
    echo

  else
    printf "chronom-cli - Chronom A.I. Command Line Interface\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli COMMAND\n"
  printf "  chronom-cli [COMMAND] --help | -h\n"
  printf "  chronom-cli --version | -v\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create Resources\n" "$(green "create")   "
  printf "  %s   List Resources\n" "$(green "list")     "
  printf "  %s   Delete Resources\n" "$(green "delete")   "
  printf "  %s   Setup shell environment\n" "$(green "setup")    "
  printf "  %s   Configure resources using chronom-cli\n" "$(green "configure")"
  printf "  %s   Upgrade Resources\n" "$(green "upgrade")  "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(yellow "--version, -v")"
    printf "    Show version number\n"
    echo

  fi
}

chronom_cli_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli create - Create Resources\n"
    echo

  else
    printf "chronom-cli create - Create Resources\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli create COMMAND\n"
  printf "  chronom-cli create [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create a new EKS Cluster\n" "$(green "cluster-eks")    "
  printf "  %s   Create a new Chronom Object\n" "$(green "chronom")        "
  printf "  %s   automatically creates an AWS ACM certificate for the given domain name, and optionally creates a DNS record in Route53 for the certificate validation\n" "$(green "certificate-acm")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_create_cluster_eks_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli create cluster-eks - Create a new EKS Cluster\n"
    echo

  else
    printf "chronom-cli create cluster-eks - Create a new EKS Cluster\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli create cluster-eks [OPTIONS]\n"
  printf "  chronom-cli create cluster-eks --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--name, -n NAME (required)")"
    printf "    The name of the EKS Cluster\n"
    echo

    printf "  %s\n" "$(yellow "--region, -r REGION (required)")"
    printf "    The AWS region to use\n"
    echo

    printf "  %s\n" "$(yellow "--create-rsa-key")"
    printf "    Create an RSA key for the cluster (Overridden by --key-pair-name)\n"
    echo

    printf "  %s\n" "$(yellow "--key-pair-name KEY-PAIR-NAME")"
    printf "    The name of the RSA key to use (if not provided, one will be generated)\n"
    echo

    printf "  %s\n" "$(yellow "--node-type NODE-TYPE")"
    printf "    The type of node to use\n"
    printf "    Default: t3.small\n"
    echo

    printf "  %s\n" "$(yellow "--node-type-large NODE-TYPE-LARGE")"
    printf "    The type of node to use\n"
    printf "    Default: t3.medium\n"
    echo

    printf "  %s\n" "$(yellow "--min-nodes MIN-NODES")"
    printf "    The minimum number of nodes to use\n"
    printf "    Default: 1\n"
    echo

    printf "  %s\n" "$(yellow "--max-nodes MAX-NODES")"
    printf "    The maximum number of nodes to use\n"
    printf "    Default: 20\n"
    echo

    printf "  %s\n" "$(yellow "--max-nodes-large MAX-NODES-LARGE")"
    printf "    The maximum number of nodes to use\n"
    printf "    Default: 15\n"
    echo

    printf "  %s\n" "$(yellow "--version, -v VERSION")"
    printf "    The Kubernetes version to use\n"
    printf "    Default: 1.27\n"
    echo

    printf "  %s\n" "$(yellow "--skip-gp3-setup")"
    printf "    Not Recommended - Skip the GP3 setup and use GP2\n"
    echo

    printf "  %s\n" "$(yellow "--setup-calico-cni")"
    printf "    Not Recommended - VPC CNI has Network Policy support, so Calico is not\n    required\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_create_chronom_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli create chronom - Create a new Chronom Object\n"
    echo

  else
    printf "chronom-cli create chronom - Create a new Chronom Object\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli create chronom COMMAND\n"
  printf "  chronom-cli create chronom [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create a new Chronom Read Only User\n" "$(green "user-iam")               "
  printf "  %s   Creates a new EKS Cluster that is ready to use with Chronom A.I.\n" "$(green "complete-deployment-eks")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_create_chronom_user_iam_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli create chronom user-iam - Create a new Chronom Read Only User\n"
    echo

  else
    printf "chronom-cli create chronom user-iam - Create a new Chronom Read Only User\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli create chronom user-iam [OPTIONS]\n"
  printf "  chronom-cli create chronom user-iam --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--name, -n NAME (required)")"
    printf "    The name of the Chronom Read Only User to be created\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_create_chronom_complete_deployment_eks_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli create chronom complete-deployment-eks\n"
    echo

    printf "  Creates a new EKS Cluster that is ready to use with Chronom A.I.\n  Creates a new Chronom Read Only User that is ready to use with Chronom A.I.\n  Creates a new Certificate Request in AWS ACM for the given domain name.\n"
    echo

  else
    printf "chronom-cli create chronom complete-deployment-eks - Creates a new EKS Cluster that is ready to use with Chronom A.I.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli create chronom complete-deployment-eks [OPTIONS]\n"
  printf "  chronom-cli create chronom complete-deployment-eks --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--name, -n NAME (required)")"
    printf "    The name of the EKS Cluster that will be created\n"
    echo

    printf "  %s\n" "$(yellow "--region, -r REGION (required)")"
    printf "    The AWS region where the EKS Cluster will be created\n"
    echo

    printf "  %s\n" "$(yellow "--version, -v VERSION")"
    printf "    The Kubernetes version to use\n"
    printf "    Default: 1.27\n"
    echo

    printf "  %s\n" "$(yellow "--node-type NODE-TYPE")"
    printf "    The type of node to use (see https://aws.amazon.com/ec2/instance-types/)\n"
    printf "    Default: t3.small\n"
    echo

    printf "  %s\n" "$(yellow "--node-type-large NODE-TYPE-LARGE")"
    printf "    The type of node to use\n"
    printf "    Default: t3.medium\n"
    echo

    printf "  %s\n" "$(yellow "--chronom-readonly-username CHRONOM-READONLY-USER")"
    printf "    The name of the Chronom Read Only User that will be created.\n    If not provided, will default to the name of the EKS Cluster with '-ro-user'\n    appended.\n"
    echo

    printf "  %s\n" "$(yellow "--create-rsa-key")"
    printf "    Create an RSA key for the cluster (Overridden by --key-pair-name)\n"
    echo

    printf "  %s\n" "$(yellow "--key-pair-name KEY-PAIR-NAME")"
    printf "    The name of the RSA key to use (if not provided, one will be generated)\n"
    echo

    printf "  %s\n" "$(yellow "--min-nodes MIN-NODES")"
    printf "    The minimum number of nodes to use\n"
    printf "    Default: 1\n"
    echo

    printf "  %s\n" "$(yellow "--max-nodes MAX-NODES")"
    printf "    The maximum number of nodes to use\n"
    printf "    Default: 25\n"
    echo

    printf "  %s\n" "$(yellow "--max-nodes-large MAX-NODES-LARGE")"
    printf "    The maximum number of nodes to use\n"
    printf "    Default: 15\n"
    echo

    printf "  %s\n" "$(yellow "--skip-gp3-setup")"
    printf "    Not Recommended - Skip the GP3 setup and use GP2\n"
    echo

    printf "  %s\n" "$(yellow "--setup-calico-cni")"
    printf "    Not Recommended - VPC CNI has Network Policy support, so Calico is not\n    required\n"
    echo

    printf "  %s\n" "$(yellow "--dns-record, -d DNS-RECORD (required)")"
    printf "    The domain name to create the certificate in AWS ACM for Chronom\n"
    echo

    printf "  %s\n" "$(yellow "--auto-validate")"
    printf "    Recommended - Automatically create a DNS record in Route53 for the\n    certificate validation.\n    This is recommended only if you are using Route53 for DNS.\n"
    echo

    printf "  %s\n" "$(yellow "--chronom-registry-username CHRONOM-REGISTRY-USERNAME")"
    printf "    The username for the Chronom A.I. Registry.\n    This value can be obtained from the Chronom A.I. Registration Email.\n"
    echo

    printf "  %s\n" "$(yellow "--chronom-auth-id CHRONOM-AUTH-ID (required)")"
    printf "    The Chronom A.I. Auth Client ID.\n    This value can be obtained from the Chronom A.I. Registration Email.\n"
    echo

    printf "  %s\n" "$(yellow "--chronom-version CHRONOM-VERSION")"
    printf "    The Chronom A.I. Version to install.\n    Defaults to the latest version at the time of release.\n"
    printf "    Default: 0.1.13\n"
    echo

    printf "  %s\n" "$(yellow "--chronom-namespace CHRONOM-NAMESPACE")"
    printf "    The Kubernetes Namespace to install Chronom A.I. into.\n    Defaults to 'chronom'.\n"
    printf "    Default: chronom\n"
    echo

    printf "  %s\n" "$(yellow "--chronom-registry-name CHRONOM-REGISTRY-NAME")"
    printf "    This value should only be set if instructed by Chronom A.I. support.\n"
    printf "    Default: chronomprodacr.azurecr.io\n"
    echo

    printf "  %s\n" "$(yellow "--skip-ingress-setup")"
    printf "    Not Recommended - Skip the Ingress setup\n"
    echo

    printf "  %s\n" "$(yellow "--skip-certificate-setup")"
    printf "    Not Recommended - Skip the Certificate setup\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

    printf "%s\n" "$(bold "Examples:")"
    printf "  chronom-cli create chronom complete-deployment-eks --name chronom-cluster\n  --region eu-north-1 --dns-record <chronom-cluster.chronom.ai> --auto-validate\n  --chronom-registry-username <chronom-registry-username> --chronom-auth-id\n  <chronom-auth-id> --create-rsa-key\n"
    echo

  fi
}

chronom_cli_create_certificate_acm_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli create certificate-acm - automatically creates an AWS ACM certificate for the given domain name, and optionally creates a DNS record in Route53 for the certificate validation\n"
    echo

  else
    printf "chronom-cli create certificate-acm - automatically creates an AWS ACM certificate for the given domain name, and optionally creates a DNS record in Route53 for the certificate validation\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli create certificate-acm [OPTIONS]\n"
  printf "  chronom-cli create certificate-acm --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--dns-record, -d DNS-RECORD (required)")"
    printf "    The domain name to create the certificate for\n"
    echo

    printf "  %s\n" "$(yellow "--region, -r REGION (required)")"
    printf "    The AWS region to use.\n    If used for Chronom, must be the same region as the EKS Cluster.\n"
    echo

    printf "  %s\n" "$(yellow "--auto-validate")"
    printf "    Automatically create a DNS record in Route53 for the certificate validation.\n    This is recommended only if you are using Route53 for DNS.\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli list - List Resources\n"
    echo

  else
    printf "chronom-cli list - List Resources\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli list COMMAND\n"
  printf "  chronom-cli list [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   List all EKS Clusters in a region\n" "$(green "cluster-eks")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_list_cluster_eks_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli list cluster-eks - List all EKS Clusters in a region\n"
    echo

  else
    printf "chronom-cli list cluster-eks - List all EKS Clusters in a region\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli list cluster-eks [OPTIONS]\n"
  printf "  chronom-cli list cluster-eks --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--region, -r REGION")"
    printf "    The AWS region to use\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli delete - Delete Resources\n"
    echo

  else
    printf "chronom-cli delete - Delete Resources\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli delete COMMAND\n"
  printf "  chronom-cli delete [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Delete a Chronom Object\n" "$(green "chronom")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_delete_chronom_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli delete chronom - Delete a Chronom Object\n"
    echo

  else
    printf "chronom-cli delete chronom - Delete a Chronom Object\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli delete chronom COMMAND\n"
  printf "  chronom-cli delete chronom [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Delete a Chronom Read Only User\n" "$(green "user-iam")   "
  printf "  %s   Delete an EKS Cluster as well as the Admin Role\n" "$(green "cluster-eks")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_delete_chronom_user_iam_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli delete chronom user-iam - Delete a Chronom Read Only User\n"
    echo

  else
    printf "chronom-cli delete chronom user-iam - Delete a Chronom Read Only User\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli delete chronom user-iam [OPTIONS]\n"
  printf "  chronom-cli delete chronom user-iam --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--name, -n NAME (required)")"
    printf "    The name of the Chronom Read Only User to be deleted\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_delete_chronom_cluster_eks_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli delete chronom cluster-eks - Delete an EKS Cluster as well as the Admin Role\n"
    echo

  else
    printf "chronom-cli delete chronom cluster-eks - Delete an EKS Cluster as well as the Admin Role\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli delete chronom cluster-eks [OPTIONS]\n"
  printf "  chronom-cli delete chronom cluster-eks --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--name, -n NAME (required)")"
    printf "    The name of the EKS Cluster to be deleted\n"
    echo

    printf "  %s\n" "$(yellow "--region, -r REGION (required)")"
    printf "    The AWS region to use\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup - Setup shell environment\n"
    echo

  else
    printf "chronom-cli setup - Setup shell environment\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup COMMAND\n"
  printf "  chronom-cli setup [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Setup auto-complete for chronom-cli\n" "$(green "auto-complete")"
  printf "  %s   Install dependencies\n" "$(green "install")      "
  printf "  %s   Setup cloudshell environment with all dependencies for chronom-cli\n" "$(green "cloudshell")   "
  printf "  %s   Installs dig\n" "$(green "dig")          "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_auto_complete_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup auto-complete - Setup auto-complete for chronom-cli\n"
    echo

  else
    printf "chronom-cli setup auto-complete - Setup auto-complete for chronom-cli\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup auto-complete [OPTIONS]\n"
  printf "  chronom-cli setup auto-complete --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--update-bashrc")"
    printf "    Update ~/.bashrc with auto-complete for chronom-cli\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup install - Install dependencies\n"
    echo

  else
    printf "chronom-cli setup install - Install dependencies\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup install COMMAND\n"
  printf "  chronom-cli setup install [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Installs AWS CLI\n" "$(green "awscli") "
  printf "  %s   Installs kubectl\n" "$(green "kubectl")"
  printf "  %s   Installs eksctl\n" "$(green "eksctl") "
  printf "  %s   Installs helm\n" "$(green "helm")   "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_install_awscli_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup install awscli - Installs AWS CLI\n"
    echo

  else
    printf "chronom-cli setup install awscli - Installs AWS CLI\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup install awscli\n"
  printf "  chronom-cli setup install awscli --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_install_kubectl_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup install kubectl - Installs kubectl\n"
    echo

  else
    printf "chronom-cli setup install kubectl - Installs kubectl\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup install kubectl\n"
  printf "  chronom-cli setup install kubectl --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_install_eksctl_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup install eksctl - Installs eksctl\n"
    echo

  else
    printf "chronom-cli setup install eksctl - Installs eksctl\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup install eksctl\n"
  printf "  chronom-cli setup install eksctl --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_install_helm_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup install helm - Installs helm\n"
    echo

  else
    printf "chronom-cli setup install helm - Installs helm\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup install helm\n"
  printf "  chronom-cli setup install helm --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_cloudshell_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup cloudshell - Setup cloudshell environment with all dependencies for chronom-cli\n"
    echo

  else
    printf "chronom-cli setup cloudshell - Setup cloudshell environment with all dependencies for chronom-cli\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup cloudshell\n"
  printf "  chronom-cli setup cloudshell --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_setup_dig_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli setup dig - Installs dig\n"
    echo

  else
    printf "chronom-cli setup dig - Installs dig\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli setup dig\n"
  printf "  chronom-cli setup dig --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_configure_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli configure - Configure resources using chronom-cli\n"
    echo

  else
    printf "chronom-cli configure - Configure resources using chronom-cli\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli configure COMMAND\n"
  printf "  chronom-cli configure [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Configure an Object to use Chronom A.I.\n" "$(green "chronom")     "
  printf "  %s   Configure the current Kubernetes context to use Chronom A.I.\n" "$(green "kube-context")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_configure_chronom_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli configure chronom - Configure an Object to use Chronom A.I.\n"
    echo

  else
    printf "chronom-cli configure chronom - Configure an Object to use Chronom A.I.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli configure chronom COMMAND\n"
  printf "  chronom-cli configure chronom [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Configures the EKS Cluster to allow Chronom Read Only user to access the cluster Kubernetes API Server\n" "$(green "additional-cluster-eks")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_configure_chronom_additional_cluster_eks_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli configure chronom additional-cluster-eks - Configures the EKS Cluster to allow Chronom Read Only user to access the cluster Kubernetes API Server\n"
    echo

  else
    printf "chronom-cli configure chronom additional-cluster-eks - Configures the EKS Cluster to allow Chronom Read Only user to access the cluster Kubernetes API Server\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli configure chronom additional-cluster-eks [OPTIONS]\n"
  printf "  chronom-cli configure chronom additional-cluster-eks --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--cluster-name CLUSTER-NAME (required)")"
    printf "    The name of the cluster to configure\n"
    echo

    printf "  %s\n" "$(yellow "--region REGION (required)")"
    printf "    The AWS region where the cluster is located\n"
    echo

    printf "  %s\n" "$(yellow "--chronom-readonly-roleArn CHRONOM-READONLY-ROLEARN (required)")"
    printf "    The ARN of the Chronom Read Only Role.\n    This value is shown in the property \"clusterCommand\" in the EKS object in\n    chronom.\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_configure_kube_context_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli configure kube-context - Configure the current Kubernetes context to use Chronom A.I.\n"
    echo

  else
    printf "chronom-cli configure kube-context - Configure the current Kubernetes context to use Chronom A.I.\n"
    echo

  fi

  printf "Alias: k\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli configure kube-context [OPTIONS]\n"
  printf "  chronom-cli configure kube-context --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--name, -n NAME (required)")"
    printf "    The name of the EKS Cluster to configure\n"
    echo

    printf "  %s\n" "$(yellow "--region, -r REGION (required)")"
    printf "    The AWS region where the EKS Cluster is located\n"
    echo

    printf "  %s\n" "$(yellow "--use-admin-role")"
    printf "    Only for Chronom Cluster - Use the Admin Role to configure the Kubernetes\n    context\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli upgrade - Upgrade Resources\n"
    echo

  else
    printf "chronom-cli upgrade - Upgrade Resources\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli upgrade COMMAND\n"
  printf "  chronom-cli upgrade [COMMAND] --help | -h\n"
  echo

  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Upgrade Chronom Version\n" "$(green "chronom")        "
  printf "  %s   Create Resources\n" "$(green "iam-permissions")"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_upgrade_chronom_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli upgrade chronom - Upgrade Chronom Version\n"
    echo

  else
    printf "chronom-cli upgrade chronom - Upgrade Chronom Version\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli upgrade chronom [OPTIONS]\n"
  printf "  chronom-cli upgrade chronom --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--version, -v VERSION (required)")"
    printf "    The Chronom A.I. Version to upgrade to\n"
    echo

    printf "  %s\n" "$(yellow "--cluster-name, -n CLUSTER-NAME (required)")"
    printf "    The name of the EKS Cluster where chronom is installed - usually\n    chronom-cluster\n"
    echo

    printf "  %s\n" "$(yellow "--region, -r REGION (required)")"
    printf "    The AWS region where the EKS Cluster is located\n"
    echo

    printf "  %s\n" "$(yellow "--namespace NAMESPACE")"
    printf "    Namespace where chronom is installed - usually chronom\n"
    printf "    Default: chronom\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_upgrade_iam_permissions_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli upgrade iam-permissions - Create Resources\n"
    echo

  else
    printf "chronom-cli upgrade iam-permissions - Create Resources\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli upgrade iam-permissions [OPTIONS]\n"
  printf "  chronom-cli upgrade iam-permissions --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--user-name USER-NAME")"
    printf "    The name of the IAM User assigned to chronom\n"
    echo

    printf "  %s\n" "$(yellow "--role-name ROLE-NAME")"
    printf "    The Name of the IAM Role assigned to chronom\n"
    echo

    printf "  %s\n" "$(yellow "--role-arn ROLE-ARN")"
    printf "    The Name of the IAM Role assigned to chronom\n"
    echo

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

chronom_cli_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "chronom-cli completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(./chronom-cli completions)\"\n"
    echo

  else
    printf "chronom-cli completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  chronom-cli completions\n"
  printf "  chronom-cli completions --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    printf "  %s\n" "$(yellow "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

chronom_helm_install() {
    clusterName="$1"
    region="$2"
    registry="$3"
    registryUsername="$4"
    registryPassword="$5"
    authClientId="$6"
    authClientSecret="$7"
    dnsRecord="$8"
    chronomVersion="$9"
    namespace="${10}"
    roAccessKey=${11}
    rwAccessKey=${12}
    ingressEnabled="${13}"
    yellow "# Installing Chronom A.I Helm Chart in the cluster $clusterName"


    token=$(aws eks get-token --cluster-name $clusterName --region $region --query "status.token" --output text)
    certificate=$(aws eks describe-cluster --name $clusterName --region $region --query "cluster.certificateAuthority.data" --output text)
    endpoint=$(aws eks describe-cluster --name $clusterName --region $region --query "cluster.endpoint" --output text)

    pemFile=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1).pem
    echo $certificate | base64 -d > $pemFile

    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile registry login $registry --username $registryUsername --password $registryPassword || (echo -e "Failed to login to registry with command: \n |helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile registry login $registry --username $registryUsername --password $registryPassword|" && exit 1)

    imageCredentials='{"registry": "'$registry'","username": "'$registryUsername'","password": "'$registryPassword'"}'

    auth='{"clientId": "'$authClientId'", "clientSecret": "'$authClientSecret'"}'

    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile install chronom oci://$registry/helm/chronom --version "$chronomVersion" --set "dnsRecord=$dnsRecord" --set "ingressEnabled=$ingressEnabled" --set "initRegion=$region" --set "secretRegion=$region" --set-json="auth=$auth" --set-json="imageCredentials=$imageCredentials" --set-json="backend=$rwAccessKey" --set-json "awsscanner=$roAccessKey" --namespace "$namespace" --create-namespace || (echo -e "Failed to install HelmChart with command: \n |helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile install chronom oci://$registry/helm/chronom --version \"$chronomVersion\" --set \"dnsRecord=$dnsRecord\" --set \"ingressEnabled=$ingressEnabled\" --set \"initRegion=$region\" --set \"secretRegion=$region\" --set-json=\"auth=$auth\" --set-json=\"imageCredentials=$imageCredentials\" --set-json=\"backend=$rwAccessKey\" --set-json \"awsscanner=$roAccessKey\" --namespace \"$namespace\" --create-namespace|" && exit 1)

    green "# Chronom A.I Helm Chart installed successfully"
    yellow "# Waiting for Ingress resource provisioning"
    sleep 10

    ingressCname=$(kubectl --server $endpoint --token $token --certificate-authority $pemFile get ingress -n $namespace -o jsonpath='{.items[].status.loadBalancer.ingress[0].hostname}')

    while [[ $ingressCname != *"$region.elb.amazonaws.com" ]]
    do
        sleep 15
        ingressCname=$(kubectl --server $endpoint --token $token --certificate-authority $pemFile get ingress -n $namespace -o jsonpath='{.items[].status.loadBalancer.ingress[0].hostname}')
    done
    green "# Ingress resource provisioned successfully"

    rm $pemFile
}

print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

configure_additional_cluster_eks() {
    clusterName="$1"
    region="$2"
    chronomReadonlyRoleArn="$3"

    chronomReadOnlyRoleName=$(echo "$chronomReadonlyRoleArn" | cut -d'/' -f2)

    yellow "# Generating Temporary Credentials for the EKS Cluster Kubernetes API Server"
    token=$(aws eks get-token --cluster-name "$clusterName" --region "$region" --query "status.token" --output text)
    certificate=$(aws eks describe-cluster --name "$clusterName" --region "$region" --query "cluster.certificateAuthority.data" --output text)
    endpoint=$(aws eks describe-cluster --name "$clusterName" --region "$region" --query "cluster.endpoint" --output text)

    pemFile=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1).pem
    echo $certificate | base64 -d > $pemFile
    green "# Temporary Credentials generated successfully"

    yellow "# Checking wether user has access to the cluster"
    canI=$(kubectl --server $endpoint --token $token --certificate-authority $pemFile auth can-i '*' '*' --all-namespaces || echo "no")
    if [ "$canI" == "no" ]; then
        red "# Unfortunately chronom-cli failed to reach the cluster"
        red "# The most common reason for this is either the user does not have access to the cluster or the cluster is private (or both)"
        endpointIp=$(dig +short "$(echo $endpoint | sed 's/https:\/\///g')" | head -n1)
        if [[ $endpointIp =~ ^10\. || $endpointIp =~ ^172\.1[6-9]\. || $endpointIp =~ ^172\.2[0-9]\. || $endpointIp =~ ^172\.3[0-1]\. || $endpointIp =~ ^192\.168\. ]]; then
            red_bold "# The cluster is private, please make sure you are connected to the cluster's VPC - This might not be the issue, but it's worth checking :)"
        fi
        red "# Please make sure you execute the command with a user that has access to the cluster"
        cloudTrail=$(aws cloudtrail lookup-events --region "$region" --lookup-attributes "AttributeKey=ResourceName,AttributeValue=$clusterName" --output json)
        possibleUsers=$(echo "$cloudTrail" | jq -r '.Events[].Username' | sort | uniq)
        if [[ -n $possibleUsers ]]; then
            red "# According to CloudTrail, the following users might have access to the cluster:"
            blue "$possibleUsers"
        fi
        red "# If you are sure you have access to the cluster, please contact Chronom Support and we will be happy to assist you"
        red "# You can contact us via email at support@chronom.ai"
        exit 1
    fi
    green "# User has access to the cluster, proceeding with the configuration"

  kubectl --server $endpoint --token $token --certificate-authority $pemFile apply -f - <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: chronomReadOnlyRole
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: chronomReadOnlyRoleBinding
subjects:
- kind: Group
  name: chronomReadOnlyGroup
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: chronomReadOnlyRole
  apiGroup: rbac.authorization.k8s.io
EOF
    eksctl create iamidentitymapping --cluster "$clusterName" --region "$region" --arn "$chronomReadonlyRoleArn" --group chronomReadOnlyGroup --username "$chronomReadOnlyRoleName"

    rm $pemFile
}

create_asm_secret() {
    clusterName="$1"
    region="$2"
    tags="$3"

    asmRoUserName="$clusterName-aws-credentials-$chronomAuthId-ro-user"
    asmRwUserName="$clusterName-aws-credentials-$chronomAuthId-rw-user"

    cleanAccessKey=$(echo $accessKey | awk '{gsub(/{|}/,"")}1')
    initialSecret="[{\"organizationId\":\"$chronomAuthId\",$cleanAccessKey,\"roleArn\":\"$roleArn\",\"accountId\":\"$accountId\",\"accountName\":\"Default Account\"}]"
    secretManagerArn=$(aws secretsmanager create-secret --name "aws-credentials-$chronomAuthId" --secret-string "$initialSecret" --region "$region" --tags "$tags" --query 'ARN' --output text)

    # Create ReadOnly ASM User
    roUserObj=$(aws iam create-user --user-name "$asmRoUserName" --tags "$tags")
    roAccessKey=$(aws iam create-access-key --user-name "$asmRoUserName" --query '{accessKeyId:AccessKey.AccessKeyId, secretAccessKey:AccessKey.SecretAccessKey}' --output json)
    roPolicyArn=$(aws iam create-policy --tags "$tags" --policy-name "$asmRoUserName-policy" --policy-document "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"readonly\",\"Effect\":\"Allow\",\"Action\":[\"secretsmanager:GetSecretValue\"],\"Resource\":\"$secretManagerArn\"}]}" --query 'Policy.Arn' --output text)
    aws iam attach-user-policy --user-name "$asmRoUserName" --policy-arn "$roPolicyArn"

    # Create ReadWrite ASM User
    rwUserObj=$(aws iam create-user --user-name "$asmRwUserName" --tags "$tags")
    rwAccessKey=$(aws iam create-access-key --user-name "$asmRwUserName" --query '{accessKeyId:AccessKey.AccessKeyId, secretAccessKey:AccessKey.SecretAccessKey}' --output json)
    rwPolicyArn=$(aws iam create-policy --policy-name "$asmRwUserName-policy" --tags "$tags" --policy-document "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"readonly\",\"Effect\":\"Allow\",\"Action\":[\"secretsmanager:GetSecretValue\",\"secretsmanager:UpdateSecret\",\"secretsmanager:PutSecretValue\"],\"Resource\":\"$secretManagerArn\"}]}" --query 'Policy.Arn' --output text)
    aws iam attach-user-policy --user-name "$asmRwUserName" --policy-arn "$rwPolicyArn"
}

create_certificate_request() {
    dnsRecord="$1"
    region="$2"

    certReqArn=$(aws acm request-certificate --domain-name $dnsRecord --tags "$tags" --validation-method DNS --region $region --output text --query "CertificateArn")
    sleep 10
    validationName=$(aws acm describe-certificate --certificate-arn $certReqArn --region $region --query "Certificate.DomainValidationOptions[?DomainName=='$dnsRecord'].ResourceRecord.Name" --output text)
    validationValue=$(aws acm describe-certificate --certificate-arn $certReqArn --region $region --query "Certificate.DomainValidationOptions[?DomainName=='$dnsRecord'].ResourceRecord.Value" --output text)
}

create_chronom_user() {
    userName="$1"
    skip="$2"

    roleName=$userName-role

    tags='[{"Key":"Application","Value":"Chronom A.I."},{"Key":"DeployedAt","Value":"UTC-'$(date --utc +%Y-%m-%d:%H:%M:%S)'"}]'

    accountId=$(aws sts get-caller-identity --query 'Account' --output text)
    externalId=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9_\-' | fold -w 32 | head -n 1)
    aws iam create-user --user-name "$userName" --tags "$tags" --query 'User.Arn' --output text
    roleArn=$(aws iam create-role --role-name "$roleName" --tags "$tags" --assume-role-policy-document "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"sts:AssumeRole\",\"Principal\":{\"AWS\":\"$accountId\"},\"Condition\":{}},{\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"arn:aws:iam::882668277426:root\"},\"Action\":\"sts:AssumeRole\",\"Condition\":{\"StringEquals\":{\"sts:ExternalId\":\"$externalId\"}}}]}" --query 'Role.Arn' --output text)
    assumePolicyArn=$(aws iam create-policy --policy-name "$userName-permissions-policy" --tags "$tags" --policy-document "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"AssumeRole\",\"Effect\":\"Allow\",\"Action\":[\"sts:AssumeRole\"],\"Resource\":[\"$roleArn\"]}]}" --query 'Policy.Arn' --output text)
    aws iam attach-user-policy --user-name "$userName" --policy-arn "$assumePolicyArn"
    curl -Os https://raw.githubusercontent.com/chronom-ai/chronom-cli/main/public_resources/chronom-readonly-additional-access-policy.json
    roPolicyArn=$(aws iam create-policy --tags "$tags" --policy-name "chronom-readonly-additional-access-policy" --policy-document file://chronom-readonly-additional-access-policy.json  --query 'Policy.Arn' --output text) || roPolicyArn=$(aws iam list-policies --query "Policies[?PolicyName=='chronom-readonly-additional-access-policy'].Arn" --output text --scope Local)
    rm chronom-readonly-additional-access-policy.json
    aws iam attach-role-policy --role-name "$roleName" --policy-arn "$roPolicyArn"
    aws iam attach-role-policy --role-name "$roleName" --policy-arn "arn:aws:iam::aws:policy/ReadOnlyAccess"
    accessKey=$(aws iam create-access-key --user-name "$userName" --query '{accessKeyId:AccessKey.AccessKeyId, secretAccessKey:AccessKey.SecretAccessKey}' --output json)

    green "# Successfull created user $userName and role $roleArn"
    green "# Please upload the data from $userName-details.yaml to Chronom's Multi Account Management page"

    if [ ! "$skip" ]; then
        echo -e "accountId: \n  $accountId" > "$userName-details.yaml"
        echo -e "accessKeyId: \n  $(echo "$accessKey" | jq -r '.accessKeyId')" >> "$userName-details.yaml"
        echo -e "accessKeySecret: \n  $(echo "$accessKey" | jq -r '.secretAccessKey')" >> "$userName-details.yaml"
        echo -e "roleArn: \n  $roleArn" >> "$userName-details.yaml"

        # using JQ Create a json file containing the account id, role arn and access key id and secret for the user
        # jq --arg accountId "$accountId" --arg accessKeyId "$(echo "$accessKey" | jq -r '.accessKeyId')" --arg accessKeySecret "$(echo "$accessKey" | jq -r '.secretAccessKey')" --arg roleArn "$roleArn" --arg externalId "$externalId" '. + {accountId: $accountId, accessKeyId: $accessKeyId, accessKeySecret: $accessKeySecret, roleArn: $roleArn, externalId: $externalId}' <<<'{}' > "chronom-details.json"

    fi
}

create_rsa_key_pair() {

    clusterName="$1"
    region="$2"

    check_available_key_pair_name $clusterName-KeyPair $region
    mkdir -p ~/.ssh
    aws ec2 create-key-pair --key-name "$clusterName-KeyPair" --region $region --query "KeyMaterial" --output text > ~/.ssh/$clusterName-KeyPair.pem
    sshKeysFlags="--ssh-access --ssh-public-key $clusterName-KeyPair"
}

create_kms_key() {
  clusterName="$1"
  region="$2"
  yellow "# Creating KMS Key"
  kmsKeyArn=$(aws kms create-key --region "$region" --description "$clusterName-kms-key" --query "KeyMetadata.Arn" --output text)
  green "# KMS Key created successfully"
  yellow "# Creating KMS Key Alias"
  aws kms create-alias --alias-name "alias/$clusterName-kms-key" --target-key-id "$kmsKeyArn" --region "$region"
  green "# KMS Key Alias created successfully"
  yellow "# Configuring Cluster Encryption"
  eksctl utils enable-secrets-encryption --cluster "$clusterName" --key-arn "$kmsKeyArn" --region "$region"
  green "# Cluster Encryption configured successfully"

}

create_vpc_cni_addon() {
    clusterName="$1"
    region="$2"

    eksctl create addon --name vpc-cni --cluster $clusterName --version latest --attach-policy-arn arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy --region $region --force
    green "# VPC-CNI addon created successfully"
    yellow "# Configuring VPC-CNI addon to support prefix delegation"
    kubectl --server $endpoint --token $token --certificate-authority $pemFile set env daemonset aws-node -n kube-system ENABLE_PREFIX_DELEGATION=true
    kubectl --server $endpoint --token $token --certificate-authority $pemFile set env ds aws-node -n kube-system WARM_PREFIX_TARGET=1
}

create_cluster_addons_bundle() {
    clusterName="$1"
    region="$2"

    yellow "# Deploying Metrics Server"
    kubectl --server $endpoint --token $token --certificate-authority $pemFile apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
    green "# Metrics Server deployed successfully"

    yellow "# Deploying Cluster Autoscaler"
    kubectl --server $endpoint --token $token --certificate-authority $pemFile apply -f <(curl -s https://raw.githubusercontent.com/chronom-ai/chronom-cli/main/public_resources/autoscaler.yaml | sed "s/<YOUR CLUSTER NAME>/$clusterName/g" )
    green "# Cluster Autoscaler deployed successfully"

    yellow "# Deploying KUBE-PROXY & COREDNS addons"
    eksctl create addon --name kube-proxy --cluster $clusterName --version latest --region $region --force
    eksctl create addon --name coredns --cluster $clusterName --version latest --region $region --force
    green "# KUBE-PROXY & COREDNS addons deployed successfully"

    yellow "# Deploying Keda Operator"
    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile repo add kedacore https://kedacore.github.io/charts
    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile repo update
    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile install keda kedacore/keda --namespace keda --create-namespace
    green "# Keda Operator deployed successfully"

}

create_cluster_elb_addon() {

    clusterName="$1"
    region="$2"
    accountId="$3"

    curl -Os https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/install/iam_policy.json
    elbIamPolicyArn=$(aws iam create-policy --policy-name $clusterName"-AWSLoadBalancerControllerIAMPolicy" --policy-document file://iam_policy.json --query "Policy.Arn" --output text )
    rm iam_policy.json
    sleep 10
    green "# Completed creation of IAM Policy with ARN: $elbIamPolicyArn"
    yellow "# Creating iam service account for AWS Load Balancer Controller"
    eksctl create iamserviceaccount --cluster $clusterName --namespace kube-system --name aws-load-balancer-controller --region $region --role-name $clusterName"-AmazonEKSLoadBalancerControllerRole" --attach-policy-arn $elbIamPolicyArn --approve
    green "# Completed creation of iam service account for AWS Load Balancer Controller"
    yellow "# Deploying AWS Load Balancer Controller"
    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile repo add eks https://aws.github.io/eks-charts && helm repo update eks
    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile install aws-load-balancer-controller eks/aws-load-balancer-controller -n kube-system --set clusterName=$clusterName --set serviceAccount.create=false --set serviceAccount.name=aws-load-balancer-controller --set region=$region
}

gp3StorageClass() {
    kubectl --server $endpoint --token $token --certificate-authority $pemFile annotate sc gp2 storageclass.kubernetes.io/is-default-class-
  kubectl --server $endpoint --token $token --certificate-authority $pemFile apply -f - <<EOF
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: gp3
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
allowVolumeExpansion: true
provisioner: ebs.csi.aws.com
volumeBindingMode: WaitForFirstConsumer
parameters:
  type: gp3
  encrypted: "true"
EOF
}

calicoClusterRole() {
    kubectl --server $endpoint --token $token --certificate-authority $pemFile create namespace tigera-operator
    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile repo add projectcalico https://docs.tigera.io/calico/charts
    helm --kube-apiserver $endpoint --kube-token $token --kube-ca-file $pemFile install calico projectcalico/tigera-operator --version v3.25.1 --namespace tigera-operator
  cat << EOF > append.yaml
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - patch
EOF
    kubectl --server $endpoint --token $token --certificate-authority $pemFile apply -f <(cat <(kubectl get clusterrole aws-node -o yaml) append.yaml)
    rm append.yaml
    kubectl --server $endpoint --token $token --certificate-authority $pemFile set env daemonset aws-node -n kube-system ANNOTATE_POD_IP=true
    kubectl --server $endpoint --token $token --certificate-authority $pemFile delete pods -n calico-system -l app.kubernetes.io/name=calico-kube-controllers
}

chronomReadonlyClusterRole() {
    clusterName="$1"
    region="$2"
    chronomReadOnlyUsername="$3"
   roleArn=$(aws iam get-role --role-name "$chronomReadOnlyUsername-role" --query 'Role.Arn' --output text)

    yellow "# Generating Temporary Credentials for the EKS Cluster Kubernetes API Server"
    token=$(aws eks get-token --cluster-name "$clusterName" --region "$region" --query "status.token" --output text)
    certificate=$(aws eks describe-cluster --name "$clusterName" --region "$region" --query "cluster.certificateAuthority.data" --output text)
    endpoint=$(aws eks describe-cluster --name "$clusterName" --region "$region" --query "cluster.endpoint" --output text)

    pemFile=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1).pem
    echo $certificate | base64 -d > $pemFile
    green "# Temporary Credentials generated successfully"

  kubectl --server $endpoint --token $token --certificate-authority $pemFile apply -f - <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: chronomReadOnlyRole
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: chronomReadOnlyRoleBinding
subjects:
- kind: Group
  name: chronomReadOnlyGroup
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: chronomReadOnlyRole
  apiGroup: rbac.authorization.k8s.io
EOF
    eksctl create iamidentitymapping --cluster "$clusterName" --region "$region" --arn "$roleArn" --group chronomReadOnlyGroup --username "$chronomReadOnlyUsername-role"

    rm $pemFile
}

create_cluster_complete(){
    clusterName="$1"
    region="$2"
    version="$3"
    nodeType="$4"
    minNodes="$5"
    maxNodes="$6"
    accountId="$7"
    nodeTypeLarge="$8"
    maxNodesLarge="$9"

    check_available_cluster_name $clusterName $region

    if [ ${args[--key-pair-name]} ]; then
        keyPairName=${args[--key-pair-name]}
        yellow "# Using existing RSA Key Pair: $keyPairName"
        sshKeysFlags="--ssh-access --ssh-public-key $keyPairName"

        elif [ ${args[--create-rsa-key]} ]; then
        yellow "# Creating a new RSA Key Pair"
        create_rsa_key_pair $clusterName $region
        green "# RSA Key Pair created successfully"
        green "# You can find the PEM file in $(pwd)/$clusterName-KeyPair.pem"
    fi

    yellow "# Creating a new EKS Cluster in the $region region"
    eksctl create cluster --name $clusterName --region $region --version $version --without-nodegroup --managed --with-oidc --alb-ingress-access --asg-access --tags "$eksctlTags" --node-private-networking --external-dns-access $sshKeysFlags
    green "# EKS Cluster created successfully"

    yellow "# Creating a new IAM Role with Admin Access for the Kubernetes API Server"
    accountId=$(aws sts get-caller-identity --query 'Account' --output text)
    adminRoleArn=$(aws iam create-role --role-name $clusterName"-AdminRole" --tags "$tags" --assume-role-policy-document "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"sts:AssumeRole\",\"Principal\":{\"AWS\":\"$accountId\"},\"Condition\":{}}]}"  --query "Role.Arn" --output text)
    adminRolePolicyArn=$(aws iam create-policy --policy-name $clusterName"-AdminRolePolicy" --tags "$tags" --policy-document "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"AllowEKSAccess\",\"Effect\":\"Allow\",\"Action\":[\"eks:AccessKubernetesApi\",\"eks:DescribeCluster\"],\"Resource\":[\"arn:aws:eks:$region:$accountId:cluster/$clusterName\"]}]}" --query 'Policy.Arn' --output text)
    aws iam attach-role-policy --role-name $clusterName"-AdminRole" --policy-arn $adminRolePolicyArn
    eksctl create iamidentitymapping --cluster $clusterName --region $region --arn $adminRoleArn --group system:masters --username admin
    green "# IAM Role with Admin Access for the Kubernetes API Server created successfully"

    yellow "# Generating Temporary Credentials for the EKS Cluster Kubernetes API Server"
    token=$(aws eks get-token --cluster-name $clusterName --region $region --query "status.token" --output text)
    certificate=$(aws eks describe-cluster --name $clusterName --region $region --query "cluster.certificateAuthority.data" --output text)
    endpoint=$(aws eks describe-cluster --name $clusterName --region $region --query "cluster.endpoint" --output text)

    pemFile=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1).pem
    echo $certificate | base64 -d > $pemFile
    green "# Temporary Credentials generated successfully"

    yellow "# Creating VPC-CNI addon"
    create_vpc_cni_addon $clusterName $region
    green "# VPC-CNI addon configured successfully"

    create_cluster_addons_bundle $clusterName $region

    yellow "# Deploying AWS Load Balancer Controller"
    create_cluster_elb_addon $clusterName $region $accountId
    green "# AWS Load Balancer Controller deployed successfully"

    yellow "# Deploying EBS CSI Driver"
    eksctl create iamserviceaccount --name ebs-csi-controller-sa --namespace kube-system --region $region --cluster $clusterName --role-name $clusterName"-AmazonEKSEBSCSIDriverRole" --role-only --attach-policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy --approve || red "# Warning:"
    eksctl create addon --name aws-ebs-csi-driver --version latest --cluster $clusterName --region $region --service-account-role-arn arn:aws:iam::$accountId:role/$clusterName"-AmazonEKSEBSCSIDriverRole" --force
    if [ ! ${args[--skip-gp3-setup]} ]; then
        gp3StorageClass
    fi
    green "# EBS CSI Driver deployed successfully"

    if [ ${args[--setup-calico-cni]} ]; then
        yellow "# Deploying Calico CNI"
        calicoClusterRole
        green "# Calico CNI deployed successfully"
    else
        yellow "# Configuring AWS VPC CNI to support Network Policies"
        aws eks update-addon --cluster-name "$clusterName" --region "$region" --addon-name vpc-cni --resolve-conflicts PRESERVE --configuration-values '{"enableNetworkPolicy": "true"}'
        green "# AWS VPC CNI configured successfully"
    fi

    yellow "# Creating a new EKS NodeGroup in the $region region with $nodeType instance type, minimum nodes: $minNodes, maximum nodes: $maxNodes"
    largeNodeGroupSuffix=${nodeTypeLarge//./}
    eksctl create nodegroup --cluster "$clusterName" --node-type "$nodeTypeLarge" --nodes-min "3" --nodes-max "$maxNodesLarge" $sshKeysFlags --managed --max-pods-per-node 110 --asg-access --tags "$eksctlTags" --node-private-networking --external-dns-access --region "$region" --alb-ingress-access --name "$clusterName-NodeGroup-$largeNodeGroupSuffix"

    eksctl create nodegroup --cluster "$clusterName" --node-type "$nodeType" --nodes-min "$minNodes" --nodes-max "$maxNodes" $sshKeysFlags --managed --max-pods-per-node 110 --asg-access --tags "$eksctlTags" --node-private-networking --external-dns-access --region "$region" --alb-ingress-access --name $clusterName"-NodeGroup"
    green "# EKS NodeGroup created successfully"

    rm $pemFile
}

create_cname_record() {
    validationName="$1"
    validationValue="$2"
    dnsZoneId="$3"

    route53BatchRecord=$(cat <<EOM
{
  "Changes": [
    {
      "Action": "UPSERT",
      "ResourceRecordSet": {
        "Name": "$validationName",
        "Type": "CNAME",
        "TTL": 300,
        "ResourceRecords": [
          {
            "Value": "$validationValue"
          }
        ]
      }
    }
  ]
}
EOM
)
    aws route53 change-resource-record-sets --hosted-zone-id "$dnsZoneId" --change-batch "$route53BatchRecord"
}

find_create_compatible_dns_zone_cname() {
    dnsZone="$1"
    validationName="$2"
    validationValue="$3"

    zonesFound=0

    while [[ $zonesFound == 0 ]]; do
        SUBDOMAIN="${dnsZone#*.}"
        ZONE_CHECK=$(aws route53 list-hosted-zones-by-name --dns-name "$SUBDOMAIN" --query 'HostedZones' 2>&1)
        if [[ $ZONE_CHECK != *"[]"* ]]; then
            zonesFound=1
        fi

        if [[ $SUBDOMAIN != *"."* ]]; then
            zonesFound=2
        fi

        dnsZone=$SUBDOMAIN
    done
    if [[ $zonesFound == 1 ]]; then
        dnsZoneId=$(aws route53 list-hosted-zones-by-name --dns-name "$dnsZone" --query "HostedZones[?Name=='$dnsZone.'].Id" --output text)
        dnsZoneId=${dnsZoneId##*/}
        yellow "# Route53 Hosted Zone ID found: $dnsZoneId, Zone: $dnsZone, Creating CNAME record..."
        create_cname_record $validationName $validationValue $dnsZoneId
        green "# CNAME record created successfully"
    else
        red "# No Route53 Hosted Zone found for $dnsZone"
        echo
        yellow "# To manually create the CNAME record, please use the following values:"
        yellow "Name: $validationName"
        yellow "Value: $validationValue"
        yellow "TTL: 300"
        yellow "Type: CNAME"
        echo
    fi
}

install_eksctl() {
    yellow "# Checking eksctl version"
    if command -v eksctl >/dev/null 2>&1; then
        eksctl_version=$(eksctl version)
        required_version="0.153.0"

        if [[ "$(printf '%s\n' "$required_version" "$eksctl_version" | sort -V | tail -n 1)" == "$eksctl_version" ]]; then
            green "# eksctl is installed and version is greater than or equal to $required_version"
        else
            blue "# eksctl version is less than $required_version, Installing newer version"
            ARCH=amd64
            PLATFORM=$(uname -s)_$ARCH

            curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_$PLATFORM.tar.gz"

            tar -xzf eksctl_$PLATFORM.tar.gz -C /tmp && rm eksctl_$PLATFORM.tar.gz

            sudo mv /tmp/eksctl /usr/local/bin

            green "# Successfully installed eksctl locally"
        fi
    else
        red "# eksctl is not installed, installing now"
        # for ARM systems, set ARCH to: `arm64`, `armv6` or `armv7`
        ARCH=amd64
        PLATFORM=$(uname -s)_$ARCH

        curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_$PLATFORM.tar.gz"

        tar -xzf eksctl_$PLATFORM.tar.gz -C /tmp && rm eksctl_$PLATFORM.tar.gz

        sudo mv /tmp/eksctl /usr/local/bin

        green "# Successfully installed eksctl locally"
    fi

}

install_aws_cli() {
    yellow "# Checking aws CLI version"
    if command -v aws >/dev/null 2>&1; then
        aws_cli_version=$(aws --version 2>&1 | cut -d/ -f2 | cut -d' ' -f1)
        required_version="2.10.0"

        if [[ "$(printf '%s\n' "$required_version" "$aws_cli_version" | sort -V | tail -n 1)" == "$aws_cli_version" ]]; then
            green "# aws CLI is installed and version is greater than or equal to $required_version"
        else
            blue "# aws CLI version is less than $required_version, Installing newer version"
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install || ./aws/install || red "# Failed to install aws CLI"
            green "# Successfully installed AWS CLI locally"
        fi
    else
        red "# aws CLI is not installed, installing now"
        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
        unzip awscliv2.zip
        sudo ./aws/install || ./aws/install || red "# Failed to install aws CLI"
        green "# Successfully installed AWS CLI locally"
    fi
}

install_helm() {
    yellow "# Checking helm version"
    if command -v helm >/dev/null 2>&1; then
        helm_version=$(helm version --template='{{.Version}}' | cut -c2-)
        required_version="3.12.3"

        # if [[ "$(printf '%s\n' "$required_version" "$helm_version" | sort -V | tail -n 1)" == "$helm_version" ]]; then
        if [[ "$helm_version" != "$required_version" ]]; then
            green "# helm is installed and version is greater than or equal to $required_version"
        else
            blue "# helm version is less than $required_version, Installing newer version"
            curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
            chmod 700 get_helm.sh
            ./get_helm.sh --version v3.12.3
            green "# Successfully installed helm locally"
            rm get_helm.sh
        fi
    else
        red "# helm is not installed, installing now"
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh
        ./get_helm.sh --version v3.12.3
        green "# Successfully installed helm locally"
        rm get_helm.sh
    fi
}

install_kubectl() {
    yellow "# Checking kubectl version"
    if command -v kubectl >/dev/null 2>&1; then
        kubectl_version=$(kubectl version --client=true --output yaml | grep -w "gitVersion" | awk '{print $2}' | cut -c2-)
        required_version="1.25.0"

        if [[ "$(printf '%s\n' "$required_version" "$kubectl_version" | sort -V | tail -n 1)" == "$kubectl_version" ]]; then
            green "# kubectl is installed and version is greater than or equal to $required_version"
        else
            blue "# kubectl version is less than $required_version, Installing newer version"
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

            sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

            green "# Successfully installed kubectl locally"
        fi
    else
        red "# kubectl is not installed, installing now"
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

        green "# Successfully installed kubectl locally"
    fi
}

install_dig() {
    yellow "# Checking OS package manager"
    if command -v apt >/dev/null 2>&1; then
        yellow "# Detected apt package manager"
        yellow "# Installing dig"
        sudo apt update
        sudo apt install -y dnsutils
        green "# Successfully installed dig"
    elif command -v yum >/dev/null 2>&1; then
        yellow "# Detected yum package manager"
        yellow "# Installing dig"
        sudo yum update -y
        sudo yum install -y bind-utils
        green "# Successfully installed dig"
    else
        red "# OS package manager not found"
        red "# Please install bind-utils manually"
        exit 1
    fi
}

check_available_cluster_name() {
    clusterName="$1"
    region="$2"

    clustersInRegion=$(aws eks list-clusters --region $region --query "clusters" --output text) || { echo "Error: Unable to list clusters in region $region"; exit; }
    if [ "$(echo "$clustersInRegion" | grep -w "$clusterName")" ]; then
        red_bold "Error: Cluster name $clusterName already exists"
        red_bold "Please choose a different name or region"
        exit
    fi
}

check_available_key_pair_name() {

    keyPairName="$1"
    region="$2"
    keyPairsInRegion=$(aws ec2 describe-key-pairs --region $region --query "KeyPairs[].KeyName" --output text) || { echo "Error: Unable to list key pairs in region $region"; exit; }
    if [ "$(echo "$keyPairsInRegion" | grep -w "$keyPairName")" ]; then
        red_bold "Error: Key Pair $keyPairName already exists"
        red_bold "If you would like to use and existing Key Pair please pass the name using the --key-pair-name flag"
        red_bold "The Key Pair MUST be in the same region as the cluster"
        exit
    fi

}

send_completions() {
  echo $'# chronom-cli completion                                   -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_chronom-cli_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_chronom-cli_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'create chronom complete-deployment-eks\'*\'--region\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create chronom complete-deployment-eks\'*\'--name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom complete-deployment-eks\'*\'--region\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create chronom complete-deployment-eks\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create chronom complete-deployment-eks\'*\'-r\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom complete-deployment-eks\'*\'--name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure chronom additional-cluster-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--chronom-readonly-roleArn --cluster-name --help --region -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create chronom complete-deployment-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--auto-validate --chronom-auth-id --chronom-namespace --chronom-readonly-username --chronom-registry-name --chronom-registry-username --chronom-version --create-rsa-key --dns-record --help --key-pair-name --max-nodes --max-nodes-large --min-nodes --name --node-type --node-type-large --region --setup-calico-cni --skip-certificate-setup --skip-gp3-setup --skip-ingress-setup --version -d -h -n -r -v")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom complete-deployment-eks\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom complete-deployment-eks\'*\'-r\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upgrade iam-permissions\'*\'--user-name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-readonly-user")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom complete-deployment-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--auto-validate --chronom-auth-id --chronom-namespace --chronom-readonly-username --chronom-registry-name --chronom-registry-username --chronom-version --create-rsa-key --dns-record --help --key-pair-name --max-nodes --max-nodes-large --min-nodes --name --node-type --node-type-large --region --setup-calico-cni --skip-certificate-setup --skip-gp3-setup --skip-ingress-setup --version -d -h -n -r -v")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure kube-context\'*\'--region\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create chronom user-iam\'*\'--name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-readonly-user")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upgrade chronom\'*\'--cluster-name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure kube-context\'*\'--name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create cluster-eks\'*\'--region\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create chronom user-iam\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-readonly-user")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'delete chronom cluster-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --name --region -h -n -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create cluster-eks\'*\'--name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom user-iam\'*\'--name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-readonly-user")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure kube-context\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure kube-context\'*\'-r\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upgrade chronom\'*\'--region\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create chronom user-iam\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --name -h -n")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'delete chronom user-iam\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --name -h -n")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upgrade iam-permissions\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --role-arn --role-name --user-name -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c cluster-eks\'*\'--region\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create certificate-acm\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--auto-validate --dns-record --help --region -d -h -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure kube-context\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --name --region --use-admin-role -h -n -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create cluster-eks\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create cluster-eks\'*\'-r\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom user-iam\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-readonly-user")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'d chronom cluster-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --name --region -h -n -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup install kubectl\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c cluster-eks\'*\'--name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup install awscli\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup install eksctl\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure k\'*\'--region\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup auto-complete\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --update-bashrc -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create cluster-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--create-rsa-key --help --key-pair-name --max-nodes --max-nodes-large --min-nodes --name --node-type --node-type-large --region --setup-calico-cni --skip-gp3-setup --version -h -n -r -v")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom user-iam\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --name -h -n")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'d chronom user-iam\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --name -h -n")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup install helm\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure k\'*\'--name\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upgrade chronom\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upgrade chronom\'*\'-r\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c certificate-acm\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--auto-validate --dns-record --help --region -d -h -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s install kubectl\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure chronom\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h additional-cluster-eks")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c cluster-eks\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c cluster-eks\'*\'-r\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'list cluster-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --region -h -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s install awscli\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s install eksctl\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup cloudshell\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s auto-complete\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --update-bashrc -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upgrade chronom\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--cluster-name --help --namespace --region --version -h -n -r -v")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create chronom\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h complete-deployment-eks user-iam")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'delete chronom\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h cluster-eks user-iam")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s install helm\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure k\'*\'-n\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "chronom-cluster")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure k\'*\'-r\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "eu-north-1")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c cluster-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--create-rsa-key --help --key-pair-name --max-nodes --max-nodes-large --min-nodes --name --node-type --node-type-large --region --setup-calico-cni --skip-gp3-setup --version -h -n -r -v")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'l cluster-eks\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --region -h -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup install\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h awscli eksctl helm kubectl")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s cloudshell\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure k\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --name --region --use-admin-role -h -n -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c chronom\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h complete-deployment-eks user-iam")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'d chronom\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h cluster-eks user-iam")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s install\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h awscli eksctl helm kubectl")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup dig\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'configure\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h chronom k kube-context")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upgrade\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h chronom iam-permissions")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'create\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h certificate-acm chronom cluster-eks")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'delete\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h chronom")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'setup\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h auto-complete cloudshell dig install")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s dig\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'list\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h cluster-eks")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'c\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h certificate-acm chronom cluster-eks")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'l\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h cluster-eks")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'d\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h chronom")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'s\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help -h auto-complete cloudshell dig install")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_chronom-cli_completions_filter "--help --version -h -v c configure create d delete l list s setup upgrade")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _chronom-cli_completions chronom-cli'
  echo $''
  echo $'# ex: filetype=sh'
}

validate_available_dns_record() {
    [[ $(echo "$1" | grep -o "\." | wc -l) -ge 2 ]] || echo "Please enter a valid DNS Record."
}

validate_available_aws_region() {
  [[ ! "$1" == "il-central-1" ]] || echo "At the time there is an unmitigated issue with the AWS API in this region. Please choose a different region."
  [[ ! "$1" == "us-east-1" ]] || echo "At the time there is an Issue with the Availability Zones. please choose a different region."
}

validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

validate_eks_cluster_name_length() {
  [[ ${#1} -le 15 ]] || echo "must be less than or equal to 15 characters"
}

validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

validate_available_iam_user_role() {
    userName="$1"


    aws iam get-user --user-name "$userName" &> /dev/null

    [ ! $? -eq 0 ] || echo "User $userName already exists, please choose another name"


    aws iam get-role --role-name "$userName-role" &> /dev/null

    [ ! $? -eq 0 ] || echo "Role $userName-role already exists, please use a different name or provide a role name with --role-name"


    aws iam get-policy --policy-arn "arn:aws:iam::$(aws sts get-caller-identity --query 'Account' --output text):policy/$userName-permissions-policy" &> /dev/null

    [ ! $? -eq 0 ] || echo "Policy $userName-permissions-policy already exists, please use a different name"


    aws iam get-policy --policy-arn "arn:aws:iam::$(aws sts get-caller-identity --query 'Account' --output text):policy/$userName-role-permissions-policy" &> /dev/null

    [ ! $? -eq 0 ] || echo "Policy $userName-role-permissions-policy already exists, please use a different name"
}

validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

chronom_cli_create_cluster_eks_command() {
  yellow "# Creating a new EKS Cluster in the ${args[--region]} region"
  yellow "# Cluster Name: ${args[--name]}"
  yellow "# Cluster Version: ${args[--version]}"
  yellow "# Cluster Initial NodeGroup Type: ${args[--node-type]}, minimum nodes: ${args[--min-nodes]}, maximum nodes: ${args[--max-nodes]}"

  clusterName=${args[--name]}
  region=${args[--region]}
  version=${args[--version]}
  nodeType=${args[--node-type]}
  minNodes=${args[--min-nodes]}
  maxNodes=${args[--max-nodes]}
  chronomReadOnlyUsername=${args[--chronom-readonly-username]}
  chronomReadOnlyUserarn=${args[--chronom-readonly-userarn]}
  accountId=$(aws sts get-caller-identity --query 'Account' --output text)

  tags='[{"Key":"Application","Value":"Chronom A.I."},{"Key":"DeployedAt","Value":"UTC-'$(date --utc +%Y-%m-%d:%H:%M:%S)'"}]'
  eksctlTags="Application=Chronom A.I.,DeployedAt=UTC-$(date --utc +%Y-%m-%d:%H:%M:%S)"

  create_cluster_complete "$clusterName" "$region" "$version" "$nodeType" "$minNodes" "$maxNodes" "$accountId" "$nodeTypeLarge" "$maxNodesLarge"

}

chronom_cli_create_chronom_user_iam_command() {
  yellow "# Creating a new Read Only AWS IAM user and Role for Chronom"
  yellow "# User name: ${args[--name]}"
  yellow "# Role name: ${args[--name]}-role"

  userName=${args[--name]}

  create_chronom_user $userName
}

chronom_cli_create_chronom_complete_deployment_eks_command() {
  # # green_bold "# Thank you for choosing Chronom"
  # # green_bold '# Please type "yes" to confirm your concent to Chronom`s Terms of Use and EULA'
  # # read -r tmsEula
  # # echo
  # # if [ "${tmsEula,,}" != "yes" ]; then
  # #     red_bold 'You must agree to Chronom`s Terms of Use and EULA to proceed'
  # #     exit 1
  # # fi
  # # green '# Thank you for agreeing to Chronom`s Terms of Use and EULA'
  yellow "# Creating a new EKS Cluster in the ${args[--region]} region for Chronom"
  yellow "# Cluster Name: ${args[--name]}"
  yellow "# Cluster Version: ${args[--version]}"
  yellow "# Cluster Initial NodeGroup Type: ${args[--node-type]}, minimum nodes: ${args[--min-nodes]}, maximum nodes: ${args[--max-nodes]}"

  clusterName=${args[--name]}
  region=${args[--region]}
  version=${args[--version]}
  nodeType=${args[--node-type]}
  minNodes=${args[--min-nodes]}
  maxNodes=${args[--max-nodes]}
  dnsRecord=${args[--dns-record]}
  chronomAuthId=${args[--chronom-auth-id]}
  chronomVersion=${args[--chronom-version]}
  chronomRegistry=${args[--chronom-registry-name]}
  chronomNamespace=${args[--chronom-namespace]}
  nodeTypeLarge=${args[--node-type-large]}
  maxNodesLarge=${args[--max-nodes-large]}

  accountId=$(aws sts get-caller-identity --query 'Account' --output text)

  if [ ${args[--chronom-readonly-username]} ]; then
      chronomReadOnlyUsername=${args[--chronom-readonly-username]}
  else
      chronomReadOnlyUsername=$clusterName-ro-user
  fi

  if [ ${args[--skip-ingress-setup]} ]; then
      ingressEnabled=false
  else
      ingressEnabled=true
  fi

  if [ ${args[--chronom-registry-username]} ]; then
      chronomRegistryUsername=${args[--chronom-registry-username]}
  else
      chronomRegistryUsername=org-$chronomAuthId
  fi

  tags='[{"Key":"Application","Value":"Chronom A.I."},{"Key":"DeployedAt","Value":"UTC-'$(date --utc +%Y-%m-%d:%H:%M:%S)'"}]'

  eksctlTags="Application=Chronom A.I.,DeployedAt=UTC-$(date --utc +%Y-%m-%d:%H:%M:%S)"

  yellow_bold "Please enter the Chronom Auth Secret that was provided to you: "
  read -s chronomAuthSecret
  while [ ${#chronomAuthSecret} -lt 127 ]
  do
      echo
      red "Chronom Auth Secret must be 128 characters long"
      red "Please enter the Chronom Auth Secret that was provided to you: "
      read -s chronomAuthSecret
  done

  echo

  yellow_bold "Please enter the Chronom Registry Password that was provided to you: "
  read -s chronomRegistryPassword
  while [ ${#chronomRegistryPassword} -lt 51 ]
  do
      echo
      red "Chronom Registry Password must be 52 characters long"
      red "Please enter the Chronom Registry Password that was provided to you: "
      read -s chronomRegistryPassword
  done

  yellow "# Creating Chronom user"
  create_chronom_user "$chronomReadOnlyUsername" true
  green "# Chronom user created successfully"

  yellow "# Creating AWS Secret Manager Secrect $clusterName-chronom-readonly-users"
  create_asm_secret "$clusterName" "$region" "$tags"
  green "# AWS Secret Manager Secrect $clusterName-chronom-readonly-users created successfully"

  create_cluster_complete "$clusterName" "$region" "$version" "$nodeType" "$minNodes" "$maxNodes" "$accountId" "$nodeTypeLarge" "$maxNodesLarge"

  yellow "# Adding $chronomReadOnlyUsername to the cluster"
  chronomReadonlyClusterRole $clusterName $region $chronomReadOnlyUsername
  green "# $chronomReadOnlyUsername added to the cluster successfully"

  if [ ! ${args[--skip-certificate-setup]} ]; then
      create_certificate_request $dnsRecord $region
      green "# Certificate Request created successfully"
      if [ ${args[--auto-validate]} ]; then
          yellow "# Searching for Route53 Hosted Zone ID for $dnsRecord"
          find_create_compatible_dns_zone_cname $dnsRecord $validationName $validationValue
          green "# Completed"
      else
          echo
          cyan_bold "# To manually create the CNAME record, please use the following values:"
          cyan_bold "Name: $validationName"
          cyan_bold "Value: $validationValue"
          cyan_bold "TTL: 300"
          cyan_bold "Type: CNAME"
          echo
      fi
  fi

  yellow "# Deploying Chronom Helm Chart in the cluster $clusterName"

  flatRoAccessKey=$(echo $roAccessKey | jq -c . )
  flatRwAccessKey=$(echo $rwAccessKey | jq -c . )

  chronom_helm_install $clusterName $region $chronomRegistry $chronomRegistryUsername $chronomRegistryPassword $chronomAuthId $chronomAuthSecret $dnsRecord $chronomVersion $chronomNamespace $flatRoAccessKey $flatRwAccessKey $ingressEnabled
  green "# Chronom Helm Chart deployed successfully"

  if [ ! ${args[--skip-ingress-setup]} ]; then
      yellow "# Searching for Route53 Hosted Zone ID for $dnsRecord"
      yellow "# CNAME value will be: $ingressCname"
      find_create_compatible_dns_zone_cname $dnsRecord $dnsRecord $ingressCname
      green "# Completed"
  fi

  green "# Please stend by while Chronom is being deployed"
  sleep 120

  green_bold "# Congratulations! Your Chronom cluster is ready to use"
  green_bold "# If ever needed, an IAM Role $clusterName-AdminRole was created with Administrator Access to the Cluster API Server"
  green_bold "# You can access Chronom at https://$dnsRecord"
  green_bold "# Cluster Name: $clusterName in region $region"

}

chronom_cli_create_certificate_acm_command() {
  yellow "# Creating a new Certificate Request for ${args[--dns-record]} in the ${args[--region]} region"

  dnsRecord=${args[--dns-record]}
  region=${args[--region]}

  create_certificate_request $dnsRecord $region

  green "# Certificate Request created successfully"

  if [ ${args[--auto-validate]} ]; then

      yellow "# Searching for Route53 Hosted Zone ID for $dnsRecord"
      find_create_compatible_dns_zone_cname $dnsRecord $validationName $validationValue
      green "# Completed"
  else
      echo
      green "# To manually create the CNAME record, please use the following values:"
      green "Name: $validationName"
      green "Value: $validationValue"
      green "TTL: 300"
      green "Type: CNAME"
      echo

  fi
}

chronom_cli_list_cluster_eks_command() {
  if [ -z "${args[--region]}" ]; then
      regionFlag="--all-regions"
      yellow "# Listing all clusters in all regions"
  else
      regionFlag="--region ${args[--region]}"
      yellow "# Listing all clusters in ${args[--region]} region"

  fi

  eksctl get cluster $regionFlag
}

chronom_cli_delete_chronom_user_iam_command() {
  yellow "# Deleting user ${args[--name]} and role ${args[--name]}-role"

  userName=${args[--name]}

  roleName=$userName-role

  accountId=$(aws sts get-caller-identity --query 'Account' --output text)

  userPolicyArn=$(aws iam get-policy --policy-arn "arn:aws:iam::$accountId:policy/$userName-permissions-policy" --query 'Policy.Arn' --output text) || red "User Policy not found"

  rolePolicyArn=$(aws iam get-policy --policy-arn "arn:aws:iam::$accountId:policy/chronom-readonly-additional-access-policy" --query 'Policy.Arn' --output text) || red "Role Policy not found"

  yellow "# Detaching User Policy"
  aws iam detach-user-policy --user-name $userName --policy-arn $userPolicyArn || red "User Policy not found"

  yellow "# Detaching Role Policy"
  aws iam detach-role-policy --role-name $roleName --policy-arn $rolePolicyArn || red "Role Policy not found"
  aws iam detach-role-policy --role-name $roleName --policy-arn "arn:aws:iam::aws:policy/ReadOnlyAccess" || red "Role Policy not found"

  yellow "# Deleting User Policy"
  aws iam delete-policy --policy-arn $userPolicyArn || red "User Policy not found"

  yellow "# Deleting Role Policy"
  aws iam delete-policy --policy-arn $rolePolicyArn || red "Role Policy not found"

  yellow "# Deleting All User Access Key"
  IFS=',' read -ra keys <<< "$(aws iam list-access-keys --user-name "$userName" --query 'AccessKeyMetadata[].AccessKeyId' --output text | awk '{$1=$1} 1' OFS=',')"
  for key in "${keys[@]}"; do
    aws iam delete-access-key --access-key-id "$key" --user-name "$userName"
  done

  yellow "# Deleting User"
  aws iam delete-user --user-name $userName || red "User not found"

  yellow "# Deleting Role"
  aws iam delete-role --role-name $roleName || red "Role not found"

  # List all IAM users with '-aws-credentials-' in their username
  possibleUsers=$(aws iam list-users --query "Users[?contains(UserName, '-aws-credentials-')].UserName" --output text)

  # Check if any users were found
  if [[ -n "$possibleUsers" ]]; then
    # Print numbered list of possible users
    listOutput=$(echo "$possibleUsers" | awk '{for(i=1;i<=NF;i++) print i". " $i}')
    yellow "# Possible users to delete (Will also delete <UserName>-policy):"
    yellow "0. Cancel"
    yellow "$listOutput"

    # Prompt user to enter numbers of users to delete
    red_bold "WARNING: This will delete the users and their policies permanently"
    red "Enter numbers of users to delete (comma-separated, 0 to cancel): "
    read userInput

    # Check if user entered 0 to cancel
    if [[ "$userInput" != "0" ]]; then
      # Split user input into array of numbers
      IFS=',' read -ra userNumbers <<< "$userInput"
      IFS="," read -a possibleUsersArray <<< "$(echo $possibleUsers | awk '{$1=$1} 1' OFS=',')"

      # Loop through user numbers and delete corresponding users
      for userNumber in "${userNumbers[@]}"; do
        # Subtract 1 from user number to get index in possibleUsers array
        index=$((userNumber-1))
        # Check if index is valid
        if [[ "$index" -lt 0 || "$index" -ge "${#possibleUsersArray[@]}" ]]; then
          red "# Invalid user number: $userNumber"
          continue
        fi
        # Get username from possibleUsers array
        userName="${possibleUsersArray[$index]}"
        # Detach User from policy, remove access keys, and delete user and policy
        yellow "# Deleting user $userName"
        aws iam detach-user-policy --user-name "$userName" --policy-arn "arn:aws:iam::$accountId:policy/$userName-policy" || red "User Policy not attached"
        IFS=',' read -ra keys <<< "$(aws iam list-access-keys --user-name "$userName" --query 'AccessKeyMetadata[].AccessKeyId' --output text | awk '{$1=$1} 1' OFS=',')"
        for key in "${keys[@]}"; do
          aws iam delete-access-key --access-key-id "$key" --user-name "$userName"
        done
        aws iam delete-user --user-name "$userName" || red "User not found"
        aws iam delete-policy --policy-arn "arn:aws:iam::$accountId:policy/$userName-policy" || red "User Policy not found"
      done
    else
      blue "No users will be deleted"
    fi
  else
    blue "No users found with '-aws-credentials-' in their username"
  fi
  green "# Successfull deleted user $userName and role $roleName"
}

chronom_cli_delete_chronom_cluster_eks_command() {
  yellow "# Deleting cluster ${args[--name]} in region ${args[--region]}"
  eksctl delete cluster --name ${args[--name]} --region ${args[--region]} || red "Cluster not found"
  green "# Successfull deleted cluster ${args[--name]} in region ${args[--region]}"
  yellow "# Deleting Admin Role ${args[--name]}-AdminRole"
  clusterName="${args[--name]}"
  roleName="${args[--name]}-AdminRole"
  accountId=$(aws sts get-caller-identity --query 'Account' --output text)
  rolePolicyArn=$(aws iam get-policy --policy-arn "arn:aws:iam::$accountId:policy/${roleName}Policy" --query 'Policy.Arn' --output text) || red "Role Policy not found"

  lbControllerPolicyArn=$(aws iam get-policy --policy-arn "arn:aws:iam::$accountId:policy/$clusterName-AWSLoadBalancerControllerIAMPolicy" --query 'Policy.Arn' --output text) || red "Load Balancer Policy not found - skipping"

  aws iam detach-role-policy --role-name "$roleName" --policy-arn "$rolePolicyArn" || red "Admin Role not found"

  aws iam delete-policy --policy-arn "$rolePolicyArn" || red "Admin Role Policy not found"

  aws iam delete-role --role-name "$roleName" || red "Admin Role not found"

  aws iam delete-policy --policy-arn "$lbControllerPolicyArn" || red "Load Balancer Policy not found - skipping"

  green "# Successfull deleted Admin Role ${args[--name]}-AdminRole"
  green "# Deletion of cluster ${args[--name]} in region ${args[--region]} completed successfully"
}

chronom_cli_setup_auto_complete_command() {
  yellow "# To configure auto complete for chronom-cli, please run the following command:"

  bold 'alias chronom-cli="./chronom-cli" && eval "$(./chronom-cli completions)"'

  magenta "# Alternatively, you can run the same command with the --update-bashrc flag to automatically update your ~/.bashrc file"

  BASHRC=~/.bashrc

  if [ -x "./chronom-cli" ]; then

      if [ "${args[--update-bashrc]}" ]; then
          yellow "# Updating ~/.bashrc"
          if ! grep -q "alias chronom-cli=\"${PWD}/chronom-cli\"" "$BASHRC"; then
              echo "alias chronom-cli=\"${PWD}/chronom-cli\"" >> "$BASHRC"
          fi
          if ! grep -q "eval \"\$(${PWD}/chronom-cli completions)\"" "$BASHRC"; then
              echo "eval \"\$(${PWD}/chronom-cli completions)\"" >> "$BASHRC"
          fi
          green '# ~/.bashrc updated successfully'
          green '# Please run the following command to reload your ~/.bashrc file'
          green 'source ~/.bashrc'
      fi
  else
      red "# Error: chronom-cli not found in current directory"
  fi
}

chronom_cli_setup_install_awscli_command() {
  install_aws_cli
}

chronom_cli_setup_install_kubectl_command() {
  install_kubectl
}

chronom_cli_setup_install_eksctl_command() {
  install_eksctl
}

chronom_cli_setup_install_helm_command() {
  install_helm
}

chronom_cli_setup_cloudshell_command() {
  yellow "# Setting up AWS CloudShell with the required dependencies"

  yellow "# Installing OpenSSL"

  sudo yum install -y openssl

  install_dig

  install_eksctl

  install_helm

  green "# Successfully configured AWS CloudShell with the required dependencies"
}

chronom_cli_setup_dig_command() {
  install_dig
}

chronom_cli_configure_chronom_additional_cluster_eks_command() {
  yellow "# Adding ${args[--chronom-readonly-roleArn]} to ${args[--cluster-name]} in ${args[--region]} region"

  clusterName=${args[--cluster-name]}
  region=${args[--region]}
  chronomReadonlyRoleArn=${args[--chronom-readonly-roleArn]}

  configure_additional_cluster_eks "$clusterName" "$region" "$chronomReadonlyRoleArn"

  green "# Done, You can now Scan the cluster with Chronom"
}

chronom_cli_configure_kube_context_command() {
  yellow "# Configuring Local Kubectl Context to use the Cluster ${args[--name]} in the region ${args[--region]}"

  clusterName=${args[--name]}
  region=${args[--region]}

  if [[ -n "${args[--use-admin-role]}" ]]; then
      yellow "# Using the Admin role $clusterName-AdminRole"
      adminRoleArn=$(aws iam get-role --role-name $clusterName-AdminRole --query 'Role.Arn' --output text)
      yellow "# Updating kubeconfig"
      eksctl utils write-kubeconfig --cluster "$clusterName" --region "$region" --set-kubeconfig-context --authenticator-role-arn "$adminRoleArn"
      green "# Done! You can now use kubectl / Helm to manage $clusterName"
  else
      yellow "# Updating kubeconfig"
      eksctl utils write-kubeconfig --cluster $clusterName --region $region --set-kubeconfig-context
      green "# Done! You can now use kubectl / Helm to manage $clusterName"
  fi
}

chronom_cli_upgrade_chronom_command() {
  yellow "# Upgrading Chronom to version ${args[--version]} in cluster ${args[--cluster-name]}"
  yellow "# Updating kubeconfig to use the cluster ${args[--cluster-name]} in the region ${args[--region]}"

  clusterName=${args[--cluster-name]}
  region=${args[--region]}
  version=${args[--version]}
  namespace=${args[--namespace]}

  currentUser=$(aws sts get-caller-identity --query Arn --output text)
  if [[ ! $currentUser =~ ^arn:aws:iam::[0-9]{12}:root$ ]]; then
      adminRoleArn=$(aws iam get-role --role-name "$clusterName-AdminRole" --query 'Role.Arn' --output text)
      eksctl utils write-kubeconfig --cluster "$clusterName" --region "$region" --set-kubeconfig-context --authenticator-role-arn "$adminRoleArn"
      elif [[ -n "${args[--i-am-root]}" ]]; then
      red "# You are currently logged in as root, but you passed the --i-am-root flag, so we will proceed with the configuration"
      red "# We feel obligated to warn you that this is not the recommended way, and you should use a user with admin permissions"
      eksctl utils write-kubeconfig --cluster "$clusterName" --region "$region" --set-kubeconfig-context
  else
      red_bold "# You are currently logged in as root, and will not be able to assume the cluster's admin role"
      red_bold "# Please login as a user with admin permissions and try again"
      red_bold "# If you would like to use the root user, please pass the --i-am-root flag"
      exit 1
  fi

  kubectl config set-context --current --namespace "$namespace"

  green "# Done! Proceeding to upgrade Chronom to version ${args[--version]} in cluster ${args[--cluster-name]}"

  yellow "# Extracting Chronom Helm registry credentials"
  registryCredentials=$(kubectl get secret chronom-registry-key -n "$namespace" -o jsonpath='{.data.\.dockerconfigjson}' | base64 --decode)

  registryAddress=$(echo $registryCredentials | jq -r '.auths' | jq -r 'keys[0]')
  registryUsername=$(echo $registryCredentials | jq -r '.auths' | jq -r '.[] | .username')
  registryPassword=$(echo $registryCredentials | jq -r '.auths' | jq -r '.[] | .password')

  helm registry login "$registryAddress" --username "$registryUsername" --password "$registryPassword"

  helm get values -n "$namespace" chronom -o yaml > values.yaml

  rabbitPass=$(kubectl get secret --namespace "$namespace" rabbitmq-chronom -o jsonpath="{.data.rabbitmq-password}" | base64 -d)

  rabbitErlangCookie=$(kubectl get secret --namespace "$namespace" rabbitmq-chronom -o jsonpath="{.data.rabbitmq-erlang-cookie}" | base64 -d)

  helm upgrade -n "$namespace" chronom "oci://${registryAddress}/helm/chronom" --version "$version" -f ./values.yaml --set "rabbitmq.auth.password=$rabbitPass" --set "rabbitmq.auth.erlangCookie=$rabbitErlangCookie" || (red_bold "# Failed to upgrade Chronom to version $version in cluster $clusterName" && rm ./values.yaml && exit 1)

  green "# Done! Chronom has been upgraded to version ${args[--version]} in cluster ${args[--cluster-name]}"
  green "# Note that it might take a moment for the new version to completly replace the old one"

  rm ./values.yaml
}

chronom_cli_upgrade_iam_permissions_command() {
  yellow "# Upgrading IAM Permissions"

  accountId=$(aws sts get-caller-identity --query 'Account' --output text)

  tags='[{"Key":"Application","Value":"Chronom A.I."},{"Key":"DeployedAt","Value":"UTC-'$(date --utc +%Y-%m-%d:%H:%M:%S)'"}]'

  # If ${args[--user-name]} was provided, role arn will be: arn:aws:iam::${accountId}:role/${args[--user-name]}-role
  # else if ${args[--role-arn]} was provided, role arn will be: ${args[--role-arn]}
  # else throw error since one of the two is required
  if [[ -n "${args[--user-name]}" ]]; then
    roleArn="arn:aws:iam::${accountId}:role/${args[--user-name]}-role"
    roleName="${args[--user-name]}-role"
  elif [[ -n "${args[--role-arn]}" ]]; then
    roleArn="${args[--role-arn]}"
    roleName="${roleArn##*/}"
  elif [[ -n "${args[--role-name]}" ]]; then
    roleArn="arn:aws:iam::${accountId}:role/${args[--role-name]}"
    roleName="${args[--role-name]}"
  else
    red "Either --user-name , --role-arn or --role-name must be provided"
    exit 1
  fi

  curl -Os https://raw.githubusercontent.com/chronom-ai/chronom-cli/main/public_resources/chronom-readonly-additional-access-policy.json

  currentAttachedPolicies=$(aws iam list-attached-role-policies --role-name "$roleName" --query 'AttachedPolicies[].PolicyArn' --output text)

  # Check if the role has the ReadOnlyAccess policy attached
  # If it doesn't, attach it
  if [[ ! "$currentAttachedPolicies" =~ .*arn:aws:iam::aws:policy/ReadOnlyAccess.* ]]; then
    yellow "# Attaching ReadOnlyAccess policy to role"
    aws iam attach-role-policy --role-name "$roleName" --policy-arn "arn:aws:iam::aws:policy/ReadOnlyAccess"
  fi

  # Check if the role has the chronom-readonly-additional-access-policy policy attached
  # If it does, compare the policy document with ./chronom-readonly-additional-access-policy.json
  # If they are different, update the policy document
  # If it doesn't, attach it
  if [[ "$currentAttachedPolicies" =~ .*arn:aws:iam::$accountId:policy/chronom-readonly-additional-access-policy.* ]]; then
  # If the policy is attached, check if it is using the latest policy document
    currentPolicyDocument=$(aws iam get-policy --policy-arn "arn:aws:iam::$accountId:policy/chronom-readonly-additional-access-policy" --query 'Policy.DefaultVersionId' --output text)
    currentPolicyDocument=$(aws iam get-policy-version --policy-arn "arn:aws:iam::$accountId:policy/chronom-readonly-additional-access-policy" --version-id "$currentPolicyDocument" --query 'PolicyVersion.Document' --output json)
    newPolicyDocument=$(cat chronom-readonly-additional-access-policy.json)
    if ! diff -q <(jq --sort-keys . <<< "$currentPolicyDocument") <(jq --sort-keys . <<< "$newPolicyDocument") &>/dev/null ; then
      yellow "# Updating chronom-readonly-additional-access-policy policy document"
      aws iam create-policy-version --policy-arn "arn:aws:iam::$accountId:policy/chronom-readonly-additional-access-policy" --policy-document file://chronom-readonly-additional-access-policy.json --set-as-default
    fi
  else
  # If the policy is not attached, check if it exists
  # If it doesn't, create it
  # If it does, check if it is using the latest policy document
  # If they are different, update the policy document
     roPolicyArn=$(aws iam list-policies --query "Policies[?PolicyName=='chronom-readonly-additional-access-policy'].Arn" --output text --scope Local)
     if [[ -z "$roPolicyArn" ]]; then
     # If the policy doesn't exist, create it
       roPolicyArn=$(aws iam create-policy --tags "$tags" --policy-name "chronom-readonly-additional-access-policy" --policy-document file://chronom-readonly-additional-access-policy.json  --query 'Policy.Arn' --output text)
     else
     # If the policy exists, check if it is using the latest policy document
       yellow "# chronom-readonly-additional-access-policy policy already exists, verifying it is using latest policy document"
        currentPolicyDocument=$(aws iam get-policy --policy-arn "$roPolicyArn" --query 'Policy.DefaultVersionId' --output text)
        newPolicyDocument=$(cat chronom-readonly-additional-access-policy.json)
        if ! diff -q <(jq --sort-keys . <<< "$currentPolicyDocument") <(jq --sort-keys . <<< "$newPolicyDocument") &>/dev/null ; then
          yellow "# Updating chronom-readonly-additional-access-policy policy document"
          aws iam create-policy-version --policy-arn "$roPolicyArn" --policy-document file://chronom-readonly-additional-access-policy.json --set-as-default
        fi
     fi
    yellow "# Attaching chronom-readonly-additional-access-policy policy to role"
    aws iam attach-role-policy --role-name "$roleName" --policy-arn "$roPolicyArn"
  fi

  rm chronom-readonly-additional-access-policy.json
  green "# Successfully upgraded IAM permissions for role $roleArn"

}

chronom_cli_completions_command() {
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add completions
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(chronom-cli completions)"
  #
  send_completions
}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        chronom_cli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    create | c)
      action="create"
      shift
      chronom_cli_create_parse_requirements "$@"
      shift $#
      ;;

    list | l)
      action="list"
      shift
      chronom_cli_list_parse_requirements "$@"
      shift $#
      ;;

    delete | d)
      action="delete"
      shift
      chronom_cli_delete_parse_requirements "$@"
      shift $#
      ;;

    setup | s)
      action="setup"
      shift
      chronom_cli_setup_parse_requirements "$@"
      shift $#
      ;;

    configure)
      action="configure"
      shift
      chronom_cli_configure_parse_requirements "$@"
      shift $#
      ;;

    upgrade)
      action="upgrade"
      shift
      chronom_cli_upgrade_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      chronom_cli_completions_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_create_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install awscli' to install aws cli and configure aws credentials - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-quickstart.html#:~:text=an%20external%20process-,Setting%20up%20new%20configuration%20and%20credentials,-The%20AWS%20CLI
  Alternatively you can install aws cli and configure aws credentials by following the official guide - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" >&2
    exit 1
  fi

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "Please install curl - https://curl.se/download.html" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    cluster-eks)
      action="cluster-eks"
      shift
      chronom_cli_create_cluster_eks_parse_requirements "$@"
      shift $#
      ;;

    chronom)
      action="chronom"
      shift
      chronom_cli_create_chronom_parse_requirements "$@"
      shift $#
      ;;

    certificate-acm)
      action="certificate-acm"
      shift
      chronom_cli_create_certificate_acm_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_create_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_create_cluster_eks_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_create_cluster_eks_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v kubectl >/dev/null 2>&1; then
    deps['kubectl']="$(command -v kubectl | head -n1)"
  else
    printf "missing dependency: kubectl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install kubectl' to install kubectl - https://kubernetes.io/docs/tasks/tools/install-kubectl/
  Alternatively you can install kubectl by following the official guide - https://kubernetes.io/docs/tasks/tools/install-kubectl/" >&2
    exit 1
  fi

  if command -v eksctl >/dev/null 2>&1; then
    deps['eksctl']="$(command -v eksctl | head -n1)"
  else
    printf "missing dependency: eksctl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install eksctl' to install eksctl - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html
  Alternatively you can install eksctl by following the official guide - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" >&2
    exit 1
  fi

  if command -v helm >/dev/null 2>&1; then
    deps['helm']="$(command -v helm | head -n1)"
  else
    printf "missing dependency: helm\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install helm' to install helm - https://helm.sh/docs/intro/install/
  Alternatively you can install helm by following the official guide - https://helm.sh/docs/intro/install/" >&2
    exit 1
  fi

  action="create cluster-eks"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --name | -n)

        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      --region | -r)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_available_aws_region "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--region, -r REGION" "$(validate_available_aws_region "$2")" >&2
            exit 1
          fi

          args['--region']="$2"
          shift
          shift
        else
          printf "%s\n" "--region requires an argument: --region, -r REGION" >&2
          exit 1
        fi
        ;;

      --create-rsa-key)

        if [[ -n "${args['--key-pair-name']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--key-pair-name" >&2
          exit 1
        fi

        args['--create-rsa-key']=1
        shift
        ;;

      --key-pair-name)

        if [[ -n "${args['--create-rsa-key']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--create-rsa-key" >&2
          exit 1
        fi

        if [[ -n ${2+x} ]]; then

          args['--key-pair-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--key-pair-name requires an argument: --key-pair-name KEY-PAIR-NAME" >&2
          exit 1
        fi
        ;;

      --node-type)

        if [[ -n ${2+x} ]]; then

          args['--node-type']="$2"
          shift
          shift
        else
          printf "%s\n" "--node-type requires an argument: --node-type NODE-TYPE" >&2
          exit 1
        fi
        ;;

      --node-type-large)

        if [[ -n ${2+x} ]]; then

          args['--node-type-large']="$2"
          shift
          shift
        else
          printf "%s\n" "--node-type-large requires an argument: --node-type-large NODE-TYPE-LARGE" >&2
          exit 1
        fi
        ;;

      --min-nodes)

        if [[ -n ${2+x} ]]; then

          args['--min-nodes']="$2"
          shift
          shift
        else
          printf "%s\n" "--min-nodes requires an argument: --min-nodes MIN-NODES" >&2
          exit 1
        fi
        ;;

      --max-nodes)

        if [[ -n ${2+x} ]]; then

          args['--max-nodes']="$2"
          shift
          shift
        else
          printf "%s\n" "--max-nodes requires an argument: --max-nodes MAX-NODES" >&2
          exit 1
        fi
        ;;

      --max-nodes-large)

        if [[ -n ${2+x} ]]; then

          args['--max-nodes-large']="$2"
          shift
          shift
        else
          printf "%s\n" "--max-nodes-large requires an argument: --max-nodes-large MAX-NODES-LARGE" >&2
          exit 1
        fi
        ;;

      --version | -v)

        if [[ -n ${2+x} ]]; then

          args['--version']="$2"
          shift
          shift
        else
          printf "%s\n" "--version requires an argument: --version, -v VERSION" >&2
          exit 1
        fi
        ;;

      --skip-gp3-setup)

        args['--skip-gp3-setup']=1
        shift
        ;;

      --setup-calico-cni)

        args['--setup-calico-cni']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--region']+x} ]]; then
    printf "missing required flag: --region, -r REGION\n" >&2
    exit 1
  fi

  [[ -n ${args['--node-type']:-} ]] || args['--node-type']="t3.small"
  [[ -n ${args['--node-type-large']:-} ]] || args['--node-type-large']="t3.medium"
  [[ -n ${args['--min-nodes']:-} ]] || args['--min-nodes']="1"
  [[ -n ${args['--max-nodes']:-} ]] || args['--max-nodes']="20"
  [[ -n ${args['--max-nodes-large']:-} ]] || args['--max-nodes-large']="15"
  [[ -n ${args['--version']:-} ]] || args['--version']="1.27"

}

chronom_cli_create_chronom_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_create_chronom_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    user-iam)
      action="user-iam"
      shift
      chronom_cli_create_chronom_user_iam_parse_requirements "$@"
      shift $#
      ;;

    complete-deployment-eks)
      action="complete-deployment-eks"
      shift
      chronom_cli_create_chronom_complete_deployment_eks_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_create_chronom_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_create_chronom_user_iam_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_create_chronom_user_iam_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="create chronom user-iam"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --name | -n)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_available_iam_user_role "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--name, -n NAME" "$(validate_available_iam_user_role "$2")" >&2
            exit 1
          fi

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi

}

chronom_cli_create_chronom_complete_deployment_eks_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_create_chronom_complete_deployment_eks_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "Please install jq - https://stedolan.github.io/jq/download/" >&2
    exit 1
  fi

  if command -v kubectl >/dev/null 2>&1; then
    deps['kubectl']="$(command -v kubectl | head -n1)"
  else
    printf "missing dependency: kubectl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install kubectl' to install kubectl - https://kubernetes.io/docs/tasks/tools/install-kubectl/
  Alternatively you can install kubectl by following the official guide - https://kubernetes.io/docs/tasks/tools/install-kubectl/" >&2
    exit 1
  fi

  if command -v eksctl >/dev/null 2>&1; then
    deps['eksctl']="$(command -v eksctl | head -n1)"
  else
    printf "missing dependency: eksctl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install eksctl' to install eksctl - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html
  Alternatively you can install eksctl by following the official guide - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" >&2
    exit 1
  fi

  if command -v helm >/dev/null 2>&1; then
    deps['helm']="$(command -v helm | head -n1)"
  else
    printf "missing dependency: helm\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install helm' to install helm - https://helm.sh/docs/intro/install/
  Alternatively you can install helm by following the official guide - https://helm.sh/docs/intro/install/" >&2
    exit 1
  fi

  action="create chronom complete-deployment-eks"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --name | -n)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_eks_cluster_name_length "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--name, -n NAME" "$(validate_eks_cluster_name_length "$2")" >&2
            exit 1
          fi

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      --region | -r)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_available_aws_region "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--region, -r REGION" "$(validate_available_aws_region "$2")" >&2
            exit 1
          fi

          args['--region']="$2"
          shift
          shift
        else
          printf "%s\n" "--region requires an argument: --region, -r REGION" >&2
          exit 1
        fi
        ;;

      --version | -v)

        if [[ -n ${2+x} ]]; then

          args['--version']="$2"
          shift
          shift
        else
          printf "%s\n" "--version requires an argument: --version, -v VERSION" >&2
          exit 1
        fi
        ;;

      --node-type)

        if [[ -n ${2+x} ]]; then

          args['--node-type']="$2"
          shift
          shift
        else
          printf "%s\n" "--node-type requires an argument: --node-type NODE-TYPE" >&2
          exit 1
        fi
        ;;

      --node-type-large)

        if [[ -n ${2+x} ]]; then

          args['--node-type-large']="$2"
          shift
          shift
        else
          printf "%s\n" "--node-type-large requires an argument: --node-type-large NODE-TYPE-LARGE" >&2
          exit 1
        fi
        ;;

      --chronom-readonly-username)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_available_iam_user_role "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--chronom-readonly-username CHRONOM-READONLY-USER" "$(validate_available_iam_user_role "$2")" >&2
            exit 1
          fi

          args['--chronom-readonly-username']="$2"
          shift
          shift
        else
          printf "%s\n" "--chronom-readonly-username requires an argument: --chronom-readonly-username CHRONOM-READONLY-USER" >&2
          exit 1
        fi
        ;;

      --create-rsa-key)

        if [[ -n "${args['--key-pair-name']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--key-pair-name" >&2
          exit 1
        fi

        args['--create-rsa-key']=1
        shift
        ;;

      --key-pair-name)

        if [[ -n "${args['--create-rsa-key']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--create-rsa-key" >&2
          exit 1
        fi

        if [[ -n ${2+x} ]]; then

          args['--key-pair-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--key-pair-name requires an argument: --key-pair-name KEY-PAIR-NAME" >&2
          exit 1
        fi
        ;;

      --min-nodes)

        if [[ -n ${2+x} ]]; then

          args['--min-nodes']="$2"
          shift
          shift
        else
          printf "%s\n" "--min-nodes requires an argument: --min-nodes MIN-NODES" >&2
          exit 1
        fi
        ;;

      --max-nodes)

        if [[ -n ${2+x} ]]; then

          args['--max-nodes']="$2"
          shift
          shift
        else
          printf "%s\n" "--max-nodes requires an argument: --max-nodes MAX-NODES" >&2
          exit 1
        fi
        ;;

      --max-nodes-large)

        if [[ -n ${2+x} ]]; then

          args['--max-nodes-large']="$2"
          shift
          shift
        else
          printf "%s\n" "--max-nodes-large requires an argument: --max-nodes-large MAX-NODES-LARGE" >&2
          exit 1
        fi
        ;;

      --skip-gp3-setup)

        args['--skip-gp3-setup']=1
        shift
        ;;

      --setup-calico-cni)

        args['--setup-calico-cni']=1
        shift
        ;;

      --dns-record | -d)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_available_dns_record "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--dns-record, -d DNS-RECORD" "$(validate_available_dns_record "$2")" >&2
            exit 1
          fi

          args['--dns-record']="$2"
          shift
          shift
        else
          printf "%s\n" "--dns-record requires an argument: --dns-record, -d DNS-RECORD" >&2
          exit 1
        fi
        ;;

      --auto-validate)

        args['--auto-validate']=1
        shift
        ;;

      --chronom-registry-username)

        if [[ -n ${2+x} ]]; then

          args['--chronom-registry-username']="$2"
          shift
          shift
        else
          printf "%s\n" "--chronom-registry-username requires an argument: --chronom-registry-username CHRONOM-REGISTRY-USERNAME" >&2
          exit 1
        fi
        ;;

      --chronom-auth-id)

        if [[ -n ${2+x} ]]; then

          args['--chronom-auth-id']="$2"
          shift
          shift
        else
          printf "%s\n" "--chronom-auth-id requires an argument: --chronom-auth-id CHRONOM-AUTH-ID" >&2
          exit 1
        fi
        ;;

      --chronom-version)

        if [[ -n ${2+x} ]]; then

          args['--chronom-version']="$2"
          shift
          shift
        else
          printf "%s\n" "--chronom-version requires an argument: --chronom-version CHRONOM-VERSION" >&2
          exit 1
        fi
        ;;

      --chronom-namespace)

        if [[ -n ${2+x} ]]; then

          args['--chronom-namespace']="$2"
          shift
          shift
        else
          printf "%s\n" "--chronom-namespace requires an argument: --chronom-namespace CHRONOM-NAMESPACE" >&2
          exit 1
        fi
        ;;

      --chronom-registry-name)

        if [[ -n ${2+x} ]]; then

          args['--chronom-registry-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--chronom-registry-name requires an argument: --chronom-registry-name CHRONOM-REGISTRY-NAME" >&2
          exit 1
        fi
        ;;

      --skip-ingress-setup)

        args['--skip-ingress-setup']=1
        shift
        ;;

      --skip-certificate-setup)

        if [[ -n "${args['--auto-validate']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--auto-validate" >&2
          exit 1
        fi

        args['--skip-certificate-setup']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--region']+x} ]]; then
    printf "missing required flag: --region, -r REGION\n" >&2
    exit 1
  fi
  if [[ -z ${args['--dns-record']+x} ]]; then
    printf "missing required flag: --dns-record, -d DNS-RECORD\n" >&2
    exit 1
  fi
  if [[ -z ${args['--chronom-auth-id']+x} ]]; then
    printf "missing required flag: --chronom-auth-id CHRONOM-AUTH-ID\n" >&2
    exit 1
  fi

  [[ -n ${args['--version']:-} ]] || args['--version']="1.27"
  [[ -n ${args['--node-type']:-} ]] || args['--node-type']="t3.small"
  [[ -n ${args['--node-type-large']:-} ]] || args['--node-type-large']="t3.medium"
  [[ -n ${args['--min-nodes']:-} ]] || args['--min-nodes']="1"
  [[ -n ${args['--max-nodes']:-} ]] || args['--max-nodes']="25"
  [[ -n ${args['--max-nodes-large']:-} ]] || args['--max-nodes-large']="15"
  [[ -n ${args['--chronom-version']:-} ]] || args['--chronom-version']="0.1.13"
  [[ -n ${args['--chronom-namespace']:-} ]] || args['--chronom-namespace']="chronom"
  [[ -n ${args['--chronom-registry-name']:-} ]] || args['--chronom-registry-name']="chronomprodacr.azurecr.io"

}

chronom_cli_create_certificate_acm_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_create_certificate_acm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v kubectl >/dev/null 2>&1; then
    deps['kubectl']="$(command -v kubectl | head -n1)"
  else
    printf "missing dependency: kubectl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install kubectl' to install kubectl - https://kubernetes.io/docs/tasks/tools/install-kubectl/
  Alternatively you can install kubectl by following the official guide - https://kubernetes.io/docs/tasks/tools/install-kubectl/" >&2
    exit 1
  fi

  if command -v eksctl >/dev/null 2>&1; then
    deps['eksctl']="$(command -v eksctl | head -n1)"
  else
    printf "missing dependency: eksctl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install eksctl' to install eksctl - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html
  Alternatively you can install eksctl by following the official guide - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" >&2
    exit 1
  fi

  if command -v helm >/dev/null 2>&1; then
    deps['helm']="$(command -v helm | head -n1)"
  else
    printf "missing dependency: helm\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install helm' to install helm - https://helm.sh/docs/intro/install/
  Alternatively you can install helm by following the official guide - https://helm.sh/docs/intro/install/" >&2
    exit 1
  fi

  action="create certificate-acm"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --dns-record | -d)

        if [[ -n ${2+x} ]]; then

          args['--dns-record']="$2"
          shift
          shift
        else
          printf "%s\n" "--dns-record requires an argument: --dns-record, -d DNS-RECORD" >&2
          exit 1
        fi
        ;;

      --region | -r)

        if [[ -n ${2+x} ]]; then

          args['--region']="$2"
          shift
          shift
        else
          printf "%s\n" "--region requires an argument: --region, -r REGION" >&2
          exit 1
        fi
        ;;

      --auto-validate)

        args['--auto-validate']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--dns-record']+x} ]]; then
    printf "missing required flag: --dns-record, -d DNS-RECORD\n" >&2
    exit 1
  fi
  if [[ -z ${args['--region']+x} ]]; then
    printf "missing required flag: --region, -r REGION\n" >&2
    exit 1
  fi

}

chronom_cli_list_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install awscli' to install aws cli and configure aws credentials - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-quickstart.html#:~:text=an%20external%20process-,Setting%20up%20new%20configuration%20and%20credentials,-The%20AWS%20CLI
  Alternatively you can install aws cli and configure aws credentials by following the official guide - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" >&2
    exit 1
  fi

  if command -v eksctl >/dev/null 2>&1; then
    deps['eksctl']="$(command -v eksctl | head -n1)"
  else
    printf "missing dependency: eksctl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install eksctl' to install eksctl - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html
  Alternatively you can install eksctl by following the official guide - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    cluster-eks)
      action="cluster-eks"
      shift
      chronom_cli_list_cluster_eks_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_list_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_list_cluster_eks_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_list_cluster_eks_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="list cluster-eks"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --region | -r)

        if [[ -n ${2+x} ]]; then

          args['--region']="$2"
          shift
          shift
        else
          printf "%s\n" "--region requires an argument: --region, -r REGION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_delete_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install awscli' to install aws cli and configure aws credentials - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-quickstart.html#:~:text=an%20external%20process-,Setting%20up%20new%20configuration%20and%20credentials,-The%20AWS%20CLI
  Alternatively you can install aws cli and configure aws credentials by following the official guide - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    chronom)
      action="chronom"
      shift
      chronom_cli_delete_chronom_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_delete_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_delete_chronom_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_delete_chronom_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    user-iam)
      action="user-iam"
      shift
      chronom_cli_delete_chronom_user_iam_parse_requirements "$@"
      shift $#
      ;;

    cluster-eks)
      action="cluster-eks"
      shift
      chronom_cli_delete_chronom_cluster_eks_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_delete_chronom_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_delete_chronom_user_iam_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_delete_chronom_user_iam_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="delete chronom user-iam"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --name | -n)

        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi

}

chronom_cli_delete_chronom_cluster_eks_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_delete_chronom_cluster_eks_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="delete chronom cluster-eks"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --name | -n)

        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      --region | -r)

        if [[ -n ${2+x} ]]; then

          args['--region']="$2"
          shift
          shift
        else
          printf "%s\n" "--region requires an argument: --region, -r REGION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--region']+x} ]]; then
    printf "missing required flag: --region, -r REGION\n" >&2
    exit 1
  fi

}

chronom_cli_setup_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    auto-complete)
      action="auto-complete"
      shift
      chronom_cli_setup_auto_complete_parse_requirements "$@"
      shift $#
      ;;

    install)
      action="install"
      shift
      chronom_cli_setup_install_parse_requirements "$@"
      shift $#
      ;;

    cloudshell)
      action="cloudshell"
      shift
      chronom_cli_setup_cloudshell_parse_requirements "$@"
      shift $#
      ;;

    dig)
      action="dig"
      shift
      chronom_cli_setup_dig_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_setup_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_setup_auto_complete_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_auto_complete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="setup auto-complete"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --update-bashrc)

        args['--update-bashrc']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_setup_install_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    awscli)
      action="awscli"
      shift
      chronom_cli_setup_install_awscli_parse_requirements "$@"
      shift $#
      ;;

    kubectl)
      action="kubectl"
      shift
      chronom_cli_setup_install_kubectl_parse_requirements "$@"
      shift $#
      ;;

    eksctl)
      action="eksctl"
      shift
      chronom_cli_setup_install_eksctl_parse_requirements "$@"
      shift $#
      ;;

    helm)
      action="helm"
      shift
      chronom_cli_setup_install_helm_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_setup_install_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_setup_install_awscli_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_install_awscli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "install curl - https://curl.se/download.html" >&2
    exit 1
  fi

  if command -v unzip >/dev/null 2>&1; then
    deps['unzip']="$(command -v unzip | head -n1)"
  else
    printf "missing dependency: unzip\n" >&2
    printf "%s\n" "install unzip - https://linuxize.com/post/how-to-install-and-use-unzip/" >&2
    exit 1
  fi

  action="setup install awscli"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_setup_install_kubectl_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_install_kubectl_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "install curl - https://curl.se/download.html" >&2
    exit 1
  fi

  if command -v tar >/dev/null 2>&1; then
    deps['tar']="$(command -v tar | head -n1)"
  else
    printf "missing dependency: tar\n" >&2
    printf "%s\n" "install tar - https://linuxize.com/post/how-to-extract-unzip-tar-gz-file/" >&2
    exit 1
  fi

  if command -v sudo >/dev/null 2>&1; then
    deps['sudo']="$(command -v sudo | head -n1)"
  else
    printf "missing dependency: sudo\n" >&2
    printf "%s\n" "if you are already root, you should be ashamed of yourself!" >&2
    exit 1
  fi

  action="setup install kubectl"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_setup_install_eksctl_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_install_eksctl_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="setup install eksctl"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_setup_install_helm_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_install_helm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "install curl - https://curl.se/download.html" >&2
    exit 1
  fi

  if command -v openssl >/dev/null 2>&1; then
    deps['openssl']="$(command -v openssl | head -n1)"
  else
    printf "missing dependency: openssl\n" >&2
    printf "%s\n" "install openssl - https://www.openssl.org/source/" >&2
    exit 1
  fi

  action="setup install helm"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_setup_cloudshell_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_cloudshell_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="setup cloudshell"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_setup_dig_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_setup_dig_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "install curl - https://curl.se/download.html" >&2
    exit 1
  fi

  if command -v tar >/dev/null 2>&1; then
    deps['tar']="$(command -v tar | head -n1)"
  else
    printf "missing dependency: tar\n" >&2
    printf "%s\n" "install tar - https://linuxize.com/post/how-to-extract-unzip-tar-gz-file/" >&2
    exit 1
  fi

  if command -v unzip >/dev/null 2>&1; then
    deps['unzip']="$(command -v unzip | head -n1)"
  else
    printf "missing dependency: unzip\n" >&2
    printf "%s\n" "install unzip - https://linuxize.com/post/how-to-install-and-use-unzip/" >&2
    exit 1
  fi

  if command -v sudo >/dev/null 2>&1; then
    deps['sudo']="$(command -v sudo | head -n1)"
  else
    printf "missing dependency: sudo\n" >&2
    printf "%s\n" "if you are already root, you should be ashamed of yourself!" >&2
    exit 1
  fi

  action="setup dig"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_configure_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_configure_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    chronom)
      action="chronom"
      shift
      chronom_cli_configure_chronom_parse_requirements "$@"
      shift $#
      ;;

    kube-context | k)
      action="kube-context"
      shift
      chronom_cli_configure_kube_context_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_configure_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_configure_chronom_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_configure_chronom_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install awscli' to install aws cli and configure aws credentials - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-quickstart.html#:~:text=an%20external%20process-,Setting%20up%20new%20configuration%20and%20credentials,-The%20AWS%20CLI
  Alternatively you can install aws cli and configure aws credentials by following the official guide - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" >&2
    exit 1
  fi

  if command -v kubectl >/dev/null 2>&1; then
    deps['kubectl']="$(command -v kubectl | head -n1)"
  else
    printf "missing dependency: kubectl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install kubectl' to install kubectl - https://kubernetes.io/docs/tasks/tools/install-kubectl/
  Alternatively you can install kubectl by following the official guide - https://kubernetes.io/docs/tasks/tools/install-kubectl/" >&2
    exit 1
  fi

  if command -v eksctl >/dev/null 2>&1; then
    deps['eksctl']="$(command -v eksctl | head -n1)"
  else
    printf "missing dependency: eksctl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install eksctl' to install eksctl - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html
  Alternatively you can install eksctl by following the official guide - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" >&2
    exit 1
  fi

  if command -v dig >/dev/null 2>&1; then
    deps['dig']="$(command -v dig | head -n1)"
  else
    printf "missing dependency: dig\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install dig' to install dig - https://linuxize.com/post/how-to-use-dig-command-to-query-dns-in-linux/
  Alternatively you can install dig by following the official guide - https://linuxize.com/post/how-to-use-dig-command-to-query-dns-in-linux/" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    additional-cluster-eks)
      action="additional-cluster-eks"
      shift
      chronom_cli_configure_chronom_additional_cluster_eks_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_configure_chronom_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_configure_chronom_additional_cluster_eks_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_configure_chronom_additional_cluster_eks_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="configure chronom additional-cluster-eks"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --cluster-name)

        if [[ -n ${2+x} ]]; then

          args['--cluster-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--cluster-name requires an argument: --cluster-name CLUSTER-NAME" >&2
          exit 1
        fi
        ;;

      --region)

        if [[ -n ${2+x} ]]; then

          args['--region']="$2"
          shift
          shift
        else
          printf "%s\n" "--region requires an argument: --region REGION" >&2
          exit 1
        fi
        ;;

      --chronom-readonly-roleArn)

        if [[ -n ${2+x} ]]; then

          args['--chronom-readonly-roleArn']="$2"
          shift
          shift
        else
          printf "%s\n" "--chronom-readonly-roleArn requires an argument: --chronom-readonly-roleArn CHRONOM-READONLY-ROLEARN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--cluster-name']+x} ]]; then
    printf "missing required flag: --cluster-name CLUSTER-NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--region']+x} ]]; then
    printf "missing required flag: --region REGION\n" >&2
    exit 1
  fi
  if [[ -z ${args['--chronom-readonly-roleArn']+x} ]]; then
    printf "missing required flag: --chronom-readonly-roleArn CHRONOM-READONLY-ROLEARN\n" >&2
    exit 1
  fi

}

chronom_cli_configure_kube_context_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_configure_kube_context_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v kubectl >/dev/null 2>&1; then
    deps['kubectl']="$(command -v kubectl | head -n1)"
  else
    printf "missing dependency: kubectl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install kubectl' to install kubectl - https://kubernetes.io/docs/tasks/tools/install-kubectl/
  Alternatively you can install kubectl by following the official guide - https://kubernetes.io/docs/tasks/tools/install-kubectl/" >&2
    exit 1
  fi

  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install awscli' to install aws cli and configure aws credentials - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-quickstart.html#:~:text=an%20external%20process-,Setting%20up%20new%20configuration%20and%20credentials,-The%20AWS%20CLI
  Alternatively you can install aws cli and configure aws credentials by following the official guide - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" >&2
    exit 1
  fi

  if command -v eksctl >/dev/null 2>&1; then
    deps['eksctl']="$(command -v eksctl | head -n1)"
  else
    printf "missing dependency: eksctl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install eksctl' to install eksctl - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html
  Alternatively you can install eksctl by following the official guide - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" >&2
    exit 1
  fi

  action="configure kube-context"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --name | -n)

        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      --region | -r)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_available_aws_region "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--region, -r REGION" "$(validate_available_aws_region "$2")" >&2
            exit 1
          fi

          args['--region']="$2"
          shift
          shift
        else
          printf "%s\n" "--region requires an argument: --region, -r REGION" >&2
          exit 1
        fi
        ;;

      --use-admin-role)

        args['--use-admin-role']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--region']+x} ]]; then
    printf "missing required flag: --region, -r REGION\n" >&2
    exit 1
  fi

}

chronom_cli_upgrade_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_upgrade_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    chronom)
      action="chronom"
      shift
      chronom_cli_upgrade_chronom_parse_requirements "$@"
      shift $#
      ;;

    iam-permissions)
      action="iam-permissions"
      shift
      chronom_cli_upgrade_iam_permissions_parse_requirements "$@"
      shift $#
      ;;

    "")
      chronom_cli_upgrade_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_upgrade_chronom_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_upgrade_chronom_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install awscli' to install aws cli and configure aws credentials - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-quickstart.html#:~:text=an%20external%20process-,Setting%20up%20new%20configuration%20and%20credentials,-The%20AWS%20CLI
  Alternatively you can install aws cli and configure aws credentials by following the official guide - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" >&2
    exit 1
  fi

  if command -v kubectl >/dev/null 2>&1; then
    deps['kubectl']="$(command -v kubectl | head -n1)"
  else
    printf "missing dependency: kubectl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install kubectl' to install kubectl - https://kubernetes.io/docs/tasks/tools/install-kubectl/
  Alternatively you can install kubectl by following the official guide - https://kubernetes.io/docs/tasks/tools/install-kubectl/" >&2
    exit 1
  fi

  if command -v eksctl >/dev/null 2>&1; then
    deps['eksctl']="$(command -v eksctl | head -n1)"
  else
    printf "missing dependency: eksctl\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install eksctl' to install eksctl - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html
  Alternatively you can install eksctl by following the official guide - https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" >&2
    exit 1
  fi

  if command -v helm >/dev/null 2>&1; then
    deps['helm']="$(command -v helm | head -n1)"
  else
    printf "missing dependency: helm\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install helm' to install helm - https://helm.sh/docs/intro/install/
  Alternatively you can install helm by following the official guide - https://helm.sh/docs/intro/install/" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "Please install jq - https://stedolan.github.io/jq/download/" >&2
    exit 1
  fi

  action="upgrade chronom"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --version | -v)

        if [[ -n ${2+x} ]]; then

          args['--version']="$2"
          shift
          shift
        else
          printf "%s\n" "--version requires an argument: --version, -v VERSION" >&2
          exit 1
        fi
        ;;

      --cluster-name | -n)

        if [[ -n ${2+x} ]]; then

          args['--cluster-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--cluster-name requires an argument: --cluster-name, -n CLUSTER-NAME" >&2
          exit 1
        fi
        ;;

      --region | -r)

        if [[ -n ${2+x} ]]; then

          if [[ -n $(validate_available_aws_region "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--region, -r REGION" "$(validate_available_aws_region "$2")" >&2
            exit 1
          fi

          args['--region']="$2"
          shift
          shift
        else
          printf "%s\n" "--region requires an argument: --region, -r REGION" >&2
          exit 1
        fi
        ;;

      --namespace)

        if [[ -n ${2+x} ]]; then

          args['--namespace']="$2"
          shift
          shift
        else
          printf "%s\n" "--namespace requires an argument: --namespace NAMESPACE" >&2
          exit 1
        fi
        ;;

      --i-am-root)

        args['--i-am-root']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--version']+x} ]]; then
    printf "missing required flag: --version, -v VERSION\n" >&2
    exit 1
  fi
  if [[ -z ${args['--cluster-name']+x} ]]; then
    printf "missing required flag: --cluster-name, -n CLUSTER-NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--region']+x} ]]; then
    printf "missing required flag: --region, -r REGION\n" >&2
    exit 1
  fi

  [[ -n ${args['--namespace']:-} ]] || args['--namespace']="chronom"

}

chronom_cli_upgrade_iam_permissions_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_upgrade_iam_permissions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "Please run './chronom-cli setup install awscli' to install aws cli and configure aws credentials - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-quickstart.html#:~:text=an%20external%20process-,Setting%20up%20new%20configuration%20and%20credentials,-The%20AWS%20CLI
  Alternatively you can install aws cli and configure aws credentials by following the official guide - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" >&2
    exit 1
  fi

  action="upgrade iam-permissions"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --user-name)

        for conflict in --role-arn --role-name; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        if [[ -n ${2+x} ]]; then

          args['--user-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--user-name requires an argument: --user-name USER-NAME" >&2
          exit 1
        fi
        ;;

      --role-name)

        for conflict in --user-name --role-arn; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        if [[ -n ${2+x} ]]; then

          args['--role-name']="$2"
          shift
          shift
        else
          printf "%s\n" "--role-name requires an argument: --role-name ROLE-NAME" >&2
          exit 1
        fi
        ;;

      --role-arn)

        for conflict in --user-name --role-name; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        if [[ -n ${2+x} ]]; then

          args['--role-arn']="$2"
          shift
          shift
        else
          printf "%s\n" "--role-arn requires an argument: --role-arn ROLE-ARN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

chronom_cli_completions_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        chronom_cli_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="completions"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

initialize() {
  version="0.0.1"
  long_usage=''
  set -e

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "create") chronom_cli_create_command ;;
    "create cluster-eks") chronom_cli_create_cluster_eks_command ;;
    "create chronom") chronom_cli_create_chronom_command ;;
    "create chronom user-iam") chronom_cli_create_chronom_user_iam_command ;;
    "create chronom complete-deployment-eks") chronom_cli_create_chronom_complete_deployment_eks_command ;;
    "create certificate-acm") chronom_cli_create_certificate_acm_command ;;
    "list") chronom_cli_list_command ;;
    "list cluster-eks") chronom_cli_list_cluster_eks_command ;;
    "delete") chronom_cli_delete_command ;;
    "delete chronom") chronom_cli_delete_chronom_command ;;
    "delete chronom user-iam") chronom_cli_delete_chronom_user_iam_command ;;
    "delete chronom cluster-eks") chronom_cli_delete_chronom_cluster_eks_command ;;
    "setup") chronom_cli_setup_command ;;
    "setup auto-complete") chronom_cli_setup_auto_complete_command ;;
    "setup install") chronom_cli_setup_install_command ;;
    "setup install awscli") chronom_cli_setup_install_awscli_command ;;
    "setup install kubectl") chronom_cli_setup_install_kubectl_command ;;
    "setup install eksctl") chronom_cli_setup_install_eksctl_command ;;
    "setup install helm") chronom_cli_setup_install_helm_command ;;
    "setup cloudshell") chronom_cli_setup_cloudshell_command ;;
    "setup dig") chronom_cli_setup_dig_command ;;
    "configure") chronom_cli_configure_command ;;
    "configure chronom") chronom_cli_configure_chronom_command ;;
    "configure chronom additional-cluster-eks") chronom_cli_configure_chronom_additional_cluster_eks_command ;;
    "configure kube-context") chronom_cli_configure_kube_context_command ;;
    "upgrade") chronom_cli_upgrade_command ;;
    "upgrade chronom") chronom_cli_upgrade_chronom_command ;;
    "upgrade iam-permissions") chronom_cli_upgrade_iam_permissions_command ;;
    "completions") chronom_cli_completions_command ;;
  esac
}

initialize
run "$@"
